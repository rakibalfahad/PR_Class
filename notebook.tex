
% Default to the notebook output style

    


% Inherit from the specified cell style.




    
\documentclass[11pt]{article}

    
    
    \usepackage[T1]{fontenc}
    % Nicer default font (+ math font) than Computer Modern for most use cases
    \usepackage{mathpazo}

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % We will generate all images so they have a width \maxwidth. This means
    % that they will get their normal width if they fit onto the page, but
    % are scaled down if they would overflow the margins.
    \makeatletter
    \def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth
    \else\Gin@nat@width\fi}
    \makeatother
    \let\Oldincludegraphics\includegraphics
    % Set max figure width to be 80% of text width, for now hardcoded.
    \renewcommand{\includegraphics}[1]{\Oldincludegraphics[width=.8\maxwidth]{#1}}
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionLabelFormat{nolabel}{}
    \captionsetup{labelformat=nolabel}

    \usepackage{adjustbox} % Used to constrain images to a maximum size 
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage[utf8x]{inputenc} % Allow utf-8 characters in the tex document
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range 
    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    

    
    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatability definitions
    \def\gt{>}
    \def\lt{<}
    % Document parameters
    \title{PythonCrashCourse}
    
    
    

    % Pygments definitions
    
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@dl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@ch\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@fm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@mb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@cpf\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sa\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % Exact colors from NB
    \definecolor{incolor}{rgb}{0.0, 0.0, 0.5}
    \definecolor{outcolor}{rgb}{0.545, 0.0, 0.0}



    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

    \begin{document}
    
    
    \maketitle
    
    

    
    \section{A Crash Course in Python}\label{a-crash-course-in-python}

\subsubsection{Author:}\label{author}

Rakib Al-Fahad Ph.D. Candidate CVPIA Lab Department of Electrical and
Computer Engineering University of Memphis Email: ralfahad@memphis.edu

\subsubsection{Ref and credit:}\label{ref-and-credit}

\href{http://www.cs.sandia.gov/~rmuller/}{Rick Muller}, Sandia National
Laboratories

    \subsection{Why Python?}\label{why-python}

Python is the programming language of choice for many scientists to a
large degree because it offers a great deal of power to analyze and
model scientific data with relatively little overhead in terms of
learning, installation or development time. It is a language you can
pick up in a weekend, and use for the rest of one's life.

The \href{http://docs.python.org/2/tutorial/}{Python Tutorial} is a
great place to start getting a feel for the language. To complement this
material, I taught a
\href{http://www.wag.caltech.edu/home/rpm/python_course/}{Python Short
Course} years ago to a group of computational chemists during a time
that I was worried the field was moving too much in the direction of
using canned software rather than developing one's own methods. I wanted
to focus on what working scientists needed to be more productive:
parsing output of other programs, building simple models, experimenting
with object oriented programming, extending the language with C, and
simple GUIs.

I'm trying to do something very similar here, to cut to the chase and
focus on what scientists need. In the last year or so, the
\href{http://ipython.org}{IPython Project} has put together a notebook
interface that I have found incredibly valuable. A large number of
people have released very good IPython Notebooks that I have taken a
huge amount of pleasure reading through. Some ones that I particularly
like include:

\begin{itemize}
\tightlist
\item
  Rob Johansson's \href{http://jrjohansson.github.io/}{excellent
  notebooks}, including
  \href{https://github.com/jrjohansson/scientific-python-lectures}{Scientific
  Computing with Python} and
  \href{https://github.com/jrjohansson/qutip-lectures}{Computational
  Quantum Physics with QuTiP} lectures;
\item
  \href{http://nbviewer.ipython.org/url/jakevdp.github.com/downloads/notebooks/XKCD_plots.ipynb}{XKCD
  style graphs in matplotlib};
\item
  \href{https://github.com/ipython/ipython/tree/master/examples/notebooks\#a-collection-of-notebooks-for-using-ipython-effectively}{A
  collection of Notebooks for using IPython effectively}
\item
  \href{https://github.com/ipython/ipython/wiki/A-gallery-of-interesting-IPython-Notebooks}{A
  gallery of interesting IPython Notebooks}
\end{itemize}

I find IPython notebooks an easy way both to get important work done in
my everyday job, as well as to communicate what I've done, how I've done
it, and why it matters to my coworkers. I find myself endlessly sweeping
the \href{http://ipython.reddit.com}{IPython subreddit} hoping someone
will post a new notebook. In the interest of putting more notebooks out
into the wild for other people to use and enjoy, I thought I would try
to recreate some of what I was trying to get across in the original
Python Short Course, updated by 15 years of Python, Numpy, Scipy,
Matplotlib, and IPython development, as well as my own experience in
using Python almost every day of this time.

    \subsection{How to Install}\label{how-to-install}

\subsubsection{Windows:}\label{windows}

https://conda.io/docs/user-guide/install/windows.html Conda link:
https://www.anaconda.com/download/\#macos Example : conda install pandas

\subsubsection{Ubuntu/MAC:}\label{ubuntumac}

https://conda.io/docs/user-guide/install/linux.html from terminal: bash
Anaconda-latest-Linux-x86\_64.sh 

    \section{I. Python Overview}\label{i.-python-overview}

This is a quick introduction to Python. There are lots of other places
to learn the language more thoroughly. I have collected a list of useful
links, including ones to other learning resources, at the end of this
notebook. If you want a little more depth,
\href{http://docs.python.org/2/tutorial/}{Python Tutorial} is a great
place to start, as is Zed Shaw's
\href{http://learnpythonthehardway.org/book/}{Learn Python the Hard
Way}.

The lessons that follow make use of the IPython notebooks. There's a
good introduction to notebooks
\href{http://ipython.org/notebook.html}{in the IPython notebook
documentation} that even has a
\href{http://www.youtube.com/watch?v=H6dLGQw9yFQ\#!}{nice video} on how
to use the notebooks. You should probably also flip through the
\href{http://ipython.org/ipython-doc/dev/interactive/tutorial.html}{IPython
tutorial} in your copious free time.

Briefly, notebooks have code cells (that are generally followed by
result cells) and text cells. The text cells are the stuff that you're
reading now. The code cells start with "In {[}{]}:" with some number
generally in the brackets. If you put your cursor in the code cell and
hit Shift-Enter, the code will run in the Python interpreter and the
result will print out in the output cell. You can then change things
around and see whether you understand what's going on. If you need to
know more, see the \href{http://ipython.org/notebook.html}{IPython
notebook documentation} or the
\href{http://ipython.org/ipython-doc/dev/interactive/tutorial.html}{IPython
tutorial}.

    \subsection{Hello World Example}\label{hello-world-example}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Hello world}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Hello world

    \end{Verbatim}

    \subsection{Using Python as a
Calculator}\label{using-python-as-a-calculator}

    Many of the things I used to use a calculator for, I now use Python for:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{l+m+mi}{2}\PY{o}{+}\PY{l+m+mi}{2}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}1}]:} 4
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{p}{(}\PY{l+m+mi}{50}\PY{o}{\PYZhy{}}\PY{l+m+mi}{5}\PY{o}{*}\PY{l+m+mi}{6}\PY{p}{)}\PY{o}{/}\PY{l+m+mi}{4}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}2}]:} 5
\end{Verbatim}
            
    (If you're typing this into an IPython notebook, or otherwise using
notebook file, you hit shift-Enter to evaluate a cell.)

    There are some gotchas compared to using a normal calculator.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{l+m+mi}{7}\PY{o}{/}\PY{l+m+mi}{3}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}3}]:} 2
\end{Verbatim}
            
    Python integer division, like C or Fortran integer division, truncates
the remainder and returns an integer. At least it does in version 2. In
version 3, Python returns a floating point number. You can get a sneak
preview of this feature in Python 2 by importing the module from the
future features:

\begin{verbatim}
from __future__ import division
\end{verbatim}

    Alternatively, you can convert one of the integers to a floating point
number, in which case the division function returns another floating
point number.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{l+m+mi}{7}\PY{o}{/}\PY{l+m+mf}{3.}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}4}]:} 2.3333333333333335
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{l+m+mi}{7}\PY{o}{/}\PY{n+nb}{float}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}5}]:} 2.3333333333333335
\end{Verbatim}
            
    In the last few lines, we have sped by a lot of things that we should
stop for a moment and explore a little more fully. We've seen, however
briefly, two different data types: \textbf{integers}, also known as
\emph{whole numbers} to the non-programming world, and \textbf{floating
point numbers}, also known (incorrectly) as \emph{decimal numbers} to
the rest of the world.

We've also seen the first instance of an \textbf{import} statement.
Python has a huge number of libraries included with the distribution. To
keep things simple, most of these variables and functions are not
accessible from a normal Python interactive session. Instead, you have
to import the name. For example, there is a \textbf{math} module
containing many useful functions. To access, say, the square root
function, you can either first

\begin{verbatim}
from math import sqrt
\end{verbatim}

and then

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{n}{sqrt}\PY{p}{(}\PY{l+m+mi}{81}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]

        ---------------------------------------------------------------------------

        NameError                                 Traceback (most recent call last)

        <ipython-input-11-18128337f01f> in <module>()
    ----> 1 sqrt(81)
    

        NameError: name 'sqrt' is not defined

    \end{Verbatim}

    or you can simply import the math library itself

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{k+kn}{import} \PY{n+nn}{math}
        \PY{n}{math}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{l+m+mi}{81}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}7}]:} 9.0
\end{Verbatim}
            
    You can define variables using the equals (=) sign:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{n}{width} \PY{o}{=} \PY{l+m+mi}{20}
        \PY{n}{length} \PY{o}{=} \PY{l+m+mi}{30}
        \PY{n}{area} \PY{o}{=} \PY{n}{length}\PY{o}{*}\PY{n}{width}
        \PY{n}{area}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}8}]:} 600
\end{Verbatim}
            
    If you try to access a variable that you haven't yet defined, you get an
error:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{n}{volume}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]

        ---------------------------------------------------------------------------
    NameError                                 Traceback (most recent call last)

        <ipython-input-9-0c7fc58f9268> in <module>()
    ----> 1 volume
    

        NameError: name 'volume' is not defined

    \end{Verbatim}

    and you need to define it:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{n}{depth} \PY{o}{=} \PY{l+m+mi}{10}
        \PY{n}{volume} \PY{o}{=} \PY{n}{area}\PY{o}{*}\PY{n}{depth}
        \PY{n}{volume}
\end{Verbatim}


    You can name a variable \emph{almost} anything you want. It needs to
start with an alphabetical character or "\_", can contain alphanumeric
charcters plus underscores ("\_"). Certain words, however, are reserved
for the language:

\begin{verbatim}
and, as, assert, break, class, continue, def, del, elif, else, except, 
exec, finally, for, from, global, if, import, in, is, lambda, not, or,
pass, print, raise, return, try, while, with, yield
\end{verbatim}

Trying to define a variable using one of these will result in a syntax
error:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{k}{return} \PY{o}{=} \PY{l+m+mi}{0}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]

          File "<ipython-input-10-2b99136d4ec6>", line 1
        return = 0
               \^{}
    SyntaxError: invalid syntax


    \end{Verbatim}

    The
\href{http://docs.python.org/2/tutorial/introduction.html\#using-python-as-a-calculator}{Python
Tutorial} has more on using Python as an interactive shell. The
\href{http://ipython.org/ipython-doc/dev/interactive/tutorial.html}{IPython
tutorial} makes a nice complement to this, since IPython has a much more
sophisticated iteractive shell.

    \subsection{Strings}\label{strings}

Strings are lists of printable characters, and can be defined using
either single quotes

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Hello, World!}\PY{l+s+s1}{\PYZsq{}}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}11}]:} 'Hello, World!'
\end{Verbatim}
            
    or double quotes

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Hello, World!}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}12}]:} 'Hello, World!'
\end{Verbatim}
            
    But not both at the same time, unless you want one of the symbols to be
part of the string.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{He}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{s a Rebel}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}13}]:} "He's a Rebel"
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{She asked, }\PY{l+s+s1}{\PYZdq{}}\PY{l+s+s1}{How are you today?}\PY{l+s+s1}{\PYZdq{}}\PY{l+s+s1}{\PYZsq{}}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}14}]:} 'She asked, "How are you today?"'
\end{Verbatim}
            
    Just like the other two data objects we're familiar with (ints and
floats), you can assign a string to a variable

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{n}{greeting} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Hello, World!}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}


    The \textbf{print} statement is often used for printing character
strings:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{k}{print} \PY{n}{greeting}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Hello, World!

    \end{Verbatim}

    But it can also print data types other than strings:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The area is }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{area}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
The area is  600

    \end{Verbatim}

    In the above snipped, the number 600 (stored in the variable "area") is
converted into a string before being printed out.

    You can use the + operator to concatenate strings together:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}18}]:} \PY{n}{statement} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Hello,}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{World!}\PY{l+s+s2}{\PYZdq{}}
         \PY{k}{print} \PY{n}{statement}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Hello,World!

    \end{Verbatim}

    Don't forget the space between the strings, if you want one there.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}19}]:} \PY{n}{statement} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Hello, }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{World!}\PY{l+s+s2}{\PYZdq{}}
         \PY{k}{print} \PY{n}{statement}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Hello, World!

    \end{Verbatim}

    You can use + to concatenate multiple strings in a single statement:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}20}]:} \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{This }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{is }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{a }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{longer }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{statement.}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
This is a longer statement.

    \end{Verbatim}

    If you have a lot of words to concatenate together, there are other,
more efficient ways to do this. But this is fine for linking a few
strings together.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}23}]:} \PY{n}{a}\PY{o}{=}\PY{l+m+mf}{5.23253}
         \PY{k}{print} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Value of a =\PYZob{}\PYZcb{} end}\PY{l+s+s1}{\PYZsq{}} \PY{o}{.}\PY{n}{format}\PY{p}{(}\PY{n}{a}\PY{p}{)}
         \PY{k}{print} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Value of a =}\PY{l+s+si}{\PYZpc{}i}\PY{l+s+s1}{ end}\PY{l+s+s1}{\PYZsq{}} \PY{o}{\PYZpc{}}\PY{k}{a}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Value of a =5.23253 end
Value of a =5 end

    \end{Verbatim}

    \subsection{Lists}\label{lists}

Very often in a programming language, one wants to keep a group of
similar items together. Python does this using a data type called
\textbf{lists}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}21}]:} \PY{n}{days\PYZus{}of\PYZus{}the\PYZus{}week} \PY{o}{=} \PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Sunday}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Monday}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Tuesday}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Wednesday}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Thursday}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Friday}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Saturday}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}
\end{Verbatim}


    You can access members of the list using the \textbf{index} of that
item:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}22}]:} \PY{n}{days\PYZus{}of\PYZus{}the\PYZus{}week}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}22}]:} 'Tuesday'
\end{Verbatim}
            
    Python lists, like C, but unlike Fortran, use 0 as the index of the
first element of a list. Thus, in this example, the 0 element is
"Sunday", 1 is "Monday", and so on. If you need to access the \emph{n}th
element from the end of the list, you can use a negative index. For
example, the -1 element of a list is the last element:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}23}]:} \PY{n}{days\PYZus{}of\PYZus{}the\PYZus{}week}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}23}]:} 'Saturday'
\end{Verbatim}
            
    You can add additional items to the list using the .append() command:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}24}]:} \PY{n}{languages} \PY{o}{=} \PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Fortran}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{C}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{C++}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}
         \PY{n}{languages}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Python}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
         \PY{k}{print} \PY{n}{languages}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
['Fortran', 'C', 'C++', 'Python']

    \end{Verbatim}

    The \textbf{range()} command is a convenient way to make sequential
lists of numbers:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}25}]:} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}25}]:} [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
\end{Verbatim}
            
    Note that range(n) starts at 0 and gives the sequential list of integers
less than n. If you want to start at a different number, use
range(start,stop)

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}26}]:} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{8}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}26}]:} [2, 3, 4, 5, 6, 7]
\end{Verbatim}
            
    The lists created above with range have a \emph{step} of 1 between
elements. You can also give a fixed step size via a third command:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}27}]:} \PY{n}{evens} \PY{o}{=} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{20}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}
         \PY{n}{evens}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}27}]:} [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}28}]:} \PY{n}{evens}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}28}]:} 6
\end{Verbatim}
            
    Lists do not have to hold the same data type. For example,

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}29}]:} \PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Today}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+m+mi}{7}\PY{p}{,}\PY{l+m+mf}{99.3}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}29}]:} ['Today', 7, 99.3, '']
\end{Verbatim}
            
    However, it's good (but not essential) to use lists for similar objects
that are somehow logically connected.

\subsubsection{\texorpdfstring{ If you want to group different data
types together into a composite data object, it's best to use
\textbf{tuples}, which we will learn about
below.}{ If you want to group different data types together into a composite data object, it's best to use tuples, which we will learn about below.}}\label{if-you-want-to-group-different-data-types-together-into-a-composite-data-object-its-best-to-use-tuples-which-we-will-learn-about-below.}

You can find out how long a list is using the \textbf{len()} command:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}30}]:} \PY{n}{help}\PY{p}{(}\PY{n+nb}{len}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Help on built-in function len in module \_\_builtin\_\_:

len({\ldots})
    len(object) -> integer
    
    Return the number of items of a sequence or collection.


    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}31}]:} \PY{n+nb}{len}\PY{p}{(}\PY{n}{evens}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}31}]:} 10
\end{Verbatim}
            
    \subsection{Iteration, Indentation, and
Blocks}\label{iteration-indentation-and-blocks}

One of the most useful things you can do with lists is to \emph{iterate}
through them, i.e. to go through each element one at a time. To do this
in Python, we use the \textbf{for} statement:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}29}]:} \PY{n}{days\PYZus{}of\PYZus{}the\PYZus{}week}\PY{o}{=} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Sunday}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Monday}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Tuesday}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Wednesday}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Thursday}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Friday}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Saturday}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
         
         \PY{k}{for} \PY{n}{day} \PY{o+ow}{in} \PY{n}{days\PYZus{}of\PYZus{}the\PYZus{}week}\PY{p}{:}
             \PY{k}{print} \PY{n}{day}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Sunday
Monday
Tuesday
Wednesday
Thursday
Friday
Saturday

    \end{Verbatim}

    This code snippet goes through each element of the list called
\textbf{days\_of\_the\_week} and assigns it to the variable
\textbf{day}. It then executes everything in the indented block (in this
case only one line of code, the print statement) using those variable
assignments. When the program has gone through every element of the
list, it exists the block.

(Almost) every programming language defines blocks of code in some way.
In Fortran, one uses END statements (ENDDO, ENDIF, etc.) to define code
blocks. In C, C++, and Perl, one uses curly braces \{\} to define these
blocks.

Python uses a colon (":"), followed by indentation level to define code
blocks. Everything at a higher level of indentation is taken to be in
the same block. In the above example the block was only a single line,
but we could have had longer blocks as well:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}33}]:} \PY{k}{for} \PY{n}{day} \PY{o+ow}{in} \PY{n}{days\PYZus{}of\PYZus{}the\PYZus{}week}\PY{p}{:}
             \PY{n}{statement} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Today is }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{day}
             \PY{k}{print} \PY{n}{statement}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Today is Sunday
Today is Monday
Today is Tuesday
Today is Wednesday
Today is Thursday
Today is Friday
Today is Saturday

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}41}]:} \PY{c+c1}{\PYZsh{}Use of enumate }
         \PY{k}{for} \PY{n}{days\PYZus{}number}\PY{p}{,} \PY{n}{day} \PY{o+ow}{in} \PY{n+nb}{enumerate}\PY{p}{(}\PY{n}{days\PYZus{}of\PYZus{}the\PYZus{}week}\PY{p}{)}\PY{p}{:}
         
             \PY{k}{print} \PY{n+nb}{str}\PY{p}{(}\PY{n}{days\PYZus{}number}\PY{p}{)} \PY{o}{+}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ day is }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{day}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
0 day is Sunday
1 day is Monday
2 day is Tuesday
3 day is Wednesday
4 day is Thursday
5 day is Friday
6 day is Saturday

    \end{Verbatim}

    The \textbf{range()} command is particularly useful with the
\textbf{for} statement to execute loops of a specified length:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}34}]:} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{)}\PY{p}{:}
             \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The square of }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{i}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ is }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{i}\PY{o}{*}\PY{n}{i}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
The square of  0  is  0
The square of  1  is  1
The square of  2  is  4
The square of  3  is  9
The square of  4  is  16
The square of  5  is  25
The square of  6  is  36
The square of  7  is  49
The square of  8  is  64
The square of  9  is  81
The square of  10  is  100
The square of  11  is  121
The square of  12  is  144
The square of  13  is  169
The square of  14  is  196
The square of  15  is  225
The square of  16  is  256
The square of  17  is  289
The square of  18  is  324
The square of  19  is  361

    \end{Verbatim}

    \subsection{Slicing}\label{slicing}

Lists and strings have something in common that you might not suspect:
they can both be treated as sequences. You already know that you can
iterate through the elements of a list. You can also iterate through the
letters in a string:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}35}]:} \PY{k}{for} \PY{n}{letter} \PY{o+ow}{in} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Sunday}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:}
             \PY{k}{print} \PY{n}{letter}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
S
u
n
d
a
y

    \end{Verbatim}

    This is only occasionally useful. Slightly more useful is the
\emph{slicing} operation, which you can also use on any sequence. We
already know that we can use \emph{indexing} to get the first element of
a list:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}36}]:} \PY{n}{days\PYZus{}of\PYZus{}the\PYZus{}week}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}36}]:} 'Sunday'
\end{Verbatim}
            
    If we want the list containing the first two elements of a list, we can
do this via

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}37}]:} \PY{n}{days\PYZus{}of\PYZus{}the\PYZus{}week}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{:}\PY{l+m+mi}{2}\PY{p}{]}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}37}]:} ['Sunday', 'Monday']
\end{Verbatim}
            
    or simply

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}38}]:} \PY{n}{days\PYZus{}of\PYZus{}the\PYZus{}week}\PY{p}{[}\PY{p}{:}\PY{l+m+mi}{2}\PY{p}{]}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}38}]:} ['Sunday', 'Monday']
\end{Verbatim}
            
    If we want the last items of the list, we can do this with negative
slicing:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}39}]:} \PY{n}{days\PYZus{}of\PYZus{}the\PYZus{}week}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{:}\PY{p}{]}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}39}]:} ['Friday', 'Saturday']
\end{Verbatim}
            
    which is somewhat logically consistent with negative indices accessing
the last elements of the list.

You can do:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}40}]:} \PY{n}{workdays} \PY{o}{=} \PY{n}{days\PYZus{}of\PYZus{}the\PYZus{}week}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{:}\PY{l+m+mi}{6}\PY{p}{]}
         \PY{k}{print} \PY{n}{workdays}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']

    \end{Verbatim}

    Since strings are sequences, you can also do this to them:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}41}]:} \PY{n}{day} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Sunday}\PY{l+s+s2}{\PYZdq{}}
         \PY{n}{abbreviation} \PY{o}{=} \PY{n}{day}\PY{p}{[}\PY{p}{:}\PY{l+m+mi}{3}\PY{p}{]}
         \PY{k}{print} \PY{n}{abbreviation}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Sun

    \end{Verbatim}

    If we really want to get fancy, we can pass a third element into the
slice, which specifies a step length (just like a third argument to the
\textbf{range()} function specifies the step):

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}42}]:} \PY{n}{numbers} \PY{o}{=} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{40}\PY{p}{)}
         \PY{n}{evens} \PY{o}{=} \PY{n}{numbers}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{:}\PY{p}{:}\PY{l+m+mi}{2}\PY{p}{]}
         \PY{n}{evens}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}42}]:} [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38]
\end{Verbatim}
            
    Note that in this example I was even able to omit the second argument,
so that the slice started at 2, went to the end of the list, and took
every second element, to generate the list of even numbers less that 40.

    \subsection{ Spliting }\label{spliting}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}49}]:} \PY{c+c1}{\PYZsh{}print(word.split(\PYZsq{}, \PYZsq{})) }
           
         \PY{n}{word} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{geeks:for:geeks}\PY{l+s+s1}{\PYZsq{}}
         
         \PY{k}{print}\PY{p}{(}\PY{n}{word}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{p}{)}\PY{p}{)} 
         \PY{c+c1}{\PYZsh{} Splitting at \PYZsq{}:\PYZsq{} }
         \PY{k}{print}\PY{p}{(}\PY{n}{word}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{:}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)} 
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
geeks:for:geeks
['geeks', 'for', 'geeks']

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}55}]:} \PY{n}{word}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}55}]:} 'g'
\end{Verbatim}
            
    \subsection{Booleans and Truth
Testing}\label{booleans-and-truth-testing}

We have now learned a few data types. We have integers and floating
point numbers, strings, and lists to contain them. We have also learned
about lists, a container that can hold any data type. We have learned to
print things out, and to iterate over items in lists. We will now learn
about \textbf{boolean} variables that can be either True or False.

We invariably need some concept of \emph{conditions} in programming to
control branching behavior, to allow a program to react differently to
different situations. If it's Monday, I'll go to work, but if it's
Sunday, I'll sleep in. To do this in Python, we use a combination of
\textbf{boolean} variables, which evaluate to either True or False, and
\textbf{if} statements, that control branching based on boolean values.

    For example:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}57}]:} \PY{k}{print} \PY{n}{day}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Saturday

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}56}]:} \PY{k}{if} \PY{n}{day} \PY{o}{==} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Sunday}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:}
             \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Sleep in}\PY{l+s+s2}{\PYZdq{}}
         \PY{k}{else}\PY{p}{:}
             \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Go to work}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Go to work

    \end{Verbatim}

    (Quick quiz: why did the snippet print "Go to work" here? What is the
variable "day" set to?)

Let's take the snippet apart to see what happened. First, note the
statement

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}44}]:} \PY{n}{day} \PY{o}{==} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Sunday}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}44}]:} True
\end{Verbatim}
            
    If we evaluate it by itself, as we just did, we see that it returns a
boolean value, False. The "==" operator performs \emph{equality
testing}. If the two items are equal, it returns True, otherwise it
returns False. In this case, it is comparing two variables, the string
"Sunday", and whatever is stored in the variable "day", which, in this
case, is the other string "Saturday". Since the two strings are not
equal to each other, the truth test has the false value.

    The if statement that contains the truth test is followed by a code
block (a colon followed by an indented block of code). If the boolean is
true, it executes the code in that block. Since it is false in the above
example, we don't see that code executed.

The first block of code is followed by an \textbf{else} statement, which
is executed if nothing else in the above if statement is true. Since the
value was false, this code is executed, which is why we see "Go to
work".

You can compare any data types in Python:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}45}]:} \PY{l+m+mi}{1} \PY{o}{==} \PY{l+m+mi}{2}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}45}]:} False
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}46}]:} \PY{l+m+mi}{50} \PY{o}{==} \PY{l+m+mi}{2}\PY{o}{*}\PY{l+m+mi}{25}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}46}]:} True
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}47}]:} \PY{l+m+mi}{3} \PY{o}{\PYZlt{}} \PY{l+m+mf}{3.14159}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}47}]:} True
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}48}]:} \PY{l+m+mi}{1} \PY{o}{==} \PY{l+m+mf}{1.0}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}48}]:} True
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}49}]:} \PY{l+m+mi}{1} \PY{o}{!=} \PY{l+m+mi}{0}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}49}]:} True
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}50}]:} \PY{l+m+mi}{1} \PY{o}{\PYZlt{}}\PY{o}{=} \PY{l+m+mi}{2}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}50}]:} True
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}51}]:} \PY{l+m+mi}{1} \PY{o}{\PYZgt{}}\PY{o}{=} \PY{l+m+mi}{1}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}51}]:} True
\end{Verbatim}
            
    We see a few other boolean operators here, all of which which should be
self-explanatory. Less than, equality, non-equality, and so on.

Particularly interesting is the 1 == 1.0 test, which is true, since even
though the two objects are different data types (integer and floating
point number), they have the same \emph{value}. There is another boolean
operator \textbf{is}, that tests whether two objects are the same
object:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}52}]:} \PY{l+m+mi}{1} \PY{o+ow}{is} \PY{l+m+mf}{1.0}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}52}]:} False
\end{Verbatim}
            
    We can do boolean tests on lists as well:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}53}]:} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{]} \PY{o}{==} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{]}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}53}]:} False
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}54}]:} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{]} \PY{o}{\PYZlt{}} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{]}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}54}]:} True
\end{Verbatim}
            
    Finally, note that you can also string multiple comparisons together,
which can result in very intuitive tests:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}55}]:} \PY{n}{hours} \PY{o}{=} \PY{l+m+mi}{5}
         \PY{l+m+mi}{0} \PY{o}{\PYZlt{}} \PY{n}{hours} \PY{o}{\PYZlt{}} \PY{l+m+mi}{24}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}55}]:} True
\end{Verbatim}
            
    If statements can have \textbf{elif} parts ("else if"), in addition to
if/else parts. For example:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}56}]:} \PY{k}{if} \PY{n}{day} \PY{o}{==} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Sunday}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:}
             \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Sleep in}\PY{l+s+s2}{\PYZdq{}}
         \PY{k}{elif} \PY{n}{day} \PY{o}{==} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Saturday}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:}
             \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Do chores}\PY{l+s+s2}{\PYZdq{}}
         \PY{k}{else}\PY{p}{:}
             \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Go to work}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Sleep in

    \end{Verbatim}

    Of course we can combine if statements with for loops, to make a snippet
that is almost interesting:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}57}]:} \PY{k}{for} \PY{n}{day} \PY{o+ow}{in} \PY{n}{days\PYZus{}of\PYZus{}the\PYZus{}week}\PY{p}{:}
             \PY{n}{statement} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Today is }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{day}
             \PY{k}{print} \PY{n}{statement}
             \PY{k}{if} \PY{n}{day} \PY{o}{==} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Sunday}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:}
                 \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{   Sleep in}\PY{l+s+s2}{\PYZdq{}}
             \PY{k}{elif} \PY{n}{day} \PY{o}{==} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Saturday}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:}
                 \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{   Do chores}\PY{l+s+s2}{\PYZdq{}}
             \PY{k}{else}\PY{p}{:}
                 \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{   Go to work}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Today is Sunday
   Sleep in
Today is Monday
   Go to work
Today is Tuesday
   Go to work
Today is Wednesday
   Go to work
Today is Thursday
   Go to work
Today is Friday
   Go to work
Today is Saturday
   Do chores

    \end{Verbatim}

    This is something of an advanced topic, but ordinary data types have
boolean values associated with them, and, indeed, in early versions of
Python there was not a separate boolean object. Essentially, anything
that was a 0 value (the integer or floating point 0, an empty string "",
or an empty list {[}{]}) was False, and everything else was true. You
can see the boolean value of any data object using the \textbf{bool()}
function.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}58}]:} \PY{n+nb}{bool}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}58}]:} True
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}59}]:} \PY{n+nb}{bool}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}59}]:} False
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}60}]:} \PY{n+nb}{bool}\PY{p}{(}\PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{This }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ is }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ a }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ list}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}60}]:} True
\end{Verbatim}
            
    \subsection{Functions}\label{functions}

We might want to use the Fibonacci snippet with different sequence
lengths. We could cut an paste the code into another cell, changing the
value of \textbf{n}, but it's easier and more useful to make a function
out of the code. We do this with the \textbf{def} statement in Python:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}62}]:} \PY{k}{def} \PY{n+nf}{fibonacci}\PY{p}{(}\PY{n}{sequence\PYZus{}length}\PY{p}{)}\PY{p}{:}
             \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Return the Fibonacci sequence of length *sequence\PYZus{}length*}\PY{l+s+s2}{\PYZdq{}}
             \PY{n}{sequence} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}
             \PY{k}{if} \PY{n}{sequence\PYZus{}length} \PY{o}{\PYZlt{}} \PY{l+m+mi}{1}\PY{p}{:}
                 \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Fibonacci sequence only defined for length 1 or greater}\PY{l+s+s2}{\PYZdq{}}
                 \PY{k}{return}
             \PY{k}{if} \PY{l+m+mi}{0} \PY{o}{\PYZlt{}} \PY{n}{sequence\PYZus{}length} \PY{o}{\PYZlt{}} \PY{l+m+mi}{3}\PY{p}{:}
                 \PY{k}{return} \PY{n}{sequence}\PY{p}{[}\PY{p}{:}\PY{n}{sequence\PYZus{}length}\PY{p}{]}
             \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,}\PY{n}{sequence\PYZus{}length}\PY{p}{)}\PY{p}{:} 
                 \PY{n}{sequence}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{sequence}\PY{p}{[}\PY{n}{i}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{+}\PY{n}{sequence}\PY{p}{[}\PY{n}{i}\PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}
             \PY{k}{return} \PY{n}{sequence}
\end{Verbatim}


    We can now call \textbf{fibonacci()} for different sequence\_lengths:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}63}]:} \PY{n}{fibonacci}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}63}]:} [0, 1]
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}64}]:} \PY{n}{fibonacci}\PY{p}{(}\PY{l+m+mi}{12}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}64}]:} [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
\end{Verbatim}
            
    Recursion can be very elegant, and can lead to very simple programs.

    \subsection{Two More Data Structures: Tuples and
Dictionaries}\label{two-more-data-structures-tuples-and-dictionaries}

Before we end the Python overview, I wanted to touch on two more data
structures that are very useful (and thus very common) in Python
programs.

A \textbf{tuple} is a sequence object like a list or a string. It's
constructed by grouping a sequence of objects together with commas,
either without brackets, or with parentheses:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}70}]:} \PY{n}{t} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{hi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+m+mf}{9.0}\PY{p}{)}
         \PY{n}{t}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}70}]:} (1, 2, 'hi', 9.0)
\end{Verbatim}
            
    Tuples are like lists, in that you can access the elements using
indices:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}71}]:} \PY{n}{t}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}71}]:} 2
\end{Verbatim}
            
    However, tuples are \emph{immutable}, you can't append to them or change
the elements of them:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}72}]:} \PY{n}{t}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{l+m+mi}{7}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]

        ---------------------------------------------------------------------------
    AttributeError                            Traceback (most recent call last)

        <ipython-input-72-50c7062b1d5f> in <module>()
    ----> 1 t.append(7)
    

        AttributeError: 'tuple' object has no attribute 'append'

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}73}]:} \PY{n}{t}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{=}\PY{l+m+mi}{77}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]

        ---------------------------------------------------------------------------
    TypeError                                 Traceback (most recent call last)

        <ipython-input-73-03cc8ba9c07d> in <module>()
    ----> 1 t[1]=77
    

        TypeError: 'tuple' object does not support item assignment

    \end{Verbatim}

    Tuples are useful anytime you want to group different pieces of data
together in an object, but don't want to create a full-fledged class
(see below) for them. For example, let's say you want the Cartesian
coordinates of some objects in your program. Tuples are a good way to do
this:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}74}]:} \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Bob}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+m+mf}{0.0}\PY{p}{,}\PY{l+m+mf}{21.0}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}74}]:} ('Bob', 0.0, 21.0)
\end{Verbatim}
            
    Again, it's not a necessary distinction, but one way to distinguish
tuples and lists is that tuples are a collection of different things,
here a name, and x and y coordinates, whereas a list is a collection of
similar things, like if we wanted a list of those coordinates:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}75}]:} \PY{n}{positions} \PY{o}{=} \PY{p}{[}
                      \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Bob}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+m+mf}{0.0}\PY{p}{,}\PY{l+m+mf}{21.0}\PY{p}{)}\PY{p}{,}
                      \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Cat}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+m+mf}{2.5}\PY{p}{,}\PY{l+m+mf}{13.1}\PY{p}{)}\PY{p}{,}
                      \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Dog}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+m+mf}{33.0}\PY{p}{,}\PY{l+m+mf}{1.2}\PY{p}{)}
                      \PY{p}{]}
\end{Verbatim}


    Tuples can be used when functions return more than one value . Say we
wanted to compute the smallest x- and y-coordinates of the above list of
objects. We could write:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}76}]:} \PY{k}{def} \PY{n+nf}{minmax}\PY{p}{(}\PY{n}{objects}\PY{p}{)}\PY{p}{:}
             \PY{n}{minx} \PY{o}{=} \PY{l+m+mf}{1e20} \PY{c+c1}{\PYZsh{} These are set to really big numbers}
             \PY{n}{miny} \PY{o}{=} \PY{l+m+mf}{1e20}
             \PY{k}{for} \PY{n}{obj} \PY{o+ow}{in} \PY{n}{objects}\PY{p}{:}
                 \PY{n}{name}\PY{p}{,}\PY{n}{x}\PY{p}{,}\PY{n}{y} \PY{o}{=} \PY{n}{obj}
                 \PY{k}{if} \PY{n}{x} \PY{o}{\PYZlt{}} \PY{n}{minx}\PY{p}{:} 
                     \PY{n}{minx} \PY{o}{=} \PY{n}{x}
                 \PY{k}{if} \PY{n}{y} \PY{o}{\PYZlt{}} \PY{n}{miny}\PY{p}{:}
                     \PY{n}{miny} \PY{o}{=} \PY{n}{y}
             \PY{k}{return} \PY{n}{minx}\PY{p}{,}\PY{n}{miny}
         
         \PY{n}{x}\PY{p}{,}\PY{n}{y} \PY{o}{=} \PY{n}{minmax}\PY{p}{(}\PY{n}{positions}\PY{p}{)}
         \PY{k}{print} \PY{n}{x}\PY{p}{,}\PY{n}{y}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
0.0 1.2

    \end{Verbatim}

    \textbf{Dictionaries} are an object called "mappings" or "associative
arrays" in other languages. Whereas a list associates an integer index
with a set of objects:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}78}]:} \PY{n}{mylist} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{9}\PY{p}{,}\PY{l+m+mi}{21}\PY{p}{]}
\end{Verbatim}


    The index in a dictionary is called the \emph{key}, and the
corresponding dictionary entry is the \emph{value}. A dictionary can use
(almost) anything as the key. Whereas lists are formed with square
brackets {[}{]}, dictionaries use curly brackets \{\}:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}79}]:} \PY{n}{ages} \PY{o}{=} \PY{p}{\PYZob{}}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Rick}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{l+m+mi}{46}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Bob}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{l+m+mi}{86}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Fred}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{l+m+mi}{21}\PY{p}{\PYZcb{}}
         \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Rick}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{s age is }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{ages}\PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Rick}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Rick's age is  46

    \end{Verbatim}

    There's also a convenient way to create dictionaries without having to
quote the keys.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}80}]:} \PY{n+nb}{dict}\PY{p}{(}\PY{n}{Rick}\PY{o}{=}\PY{l+m+mi}{46}\PY{p}{,}\PY{n}{Bob}\PY{o}{=}\PY{l+m+mi}{86}\PY{p}{,}\PY{n}{Fred}\PY{o}{=}\PY{l+m+mi}{20}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}80}]:} \{'Bob': 86, 'Fred': 20, 'Rick': 46\}
\end{Verbatim}
            
    The \textbf{len()} command works on both tuples and dictionaries:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}81}]:} \PY{n+nb}{len}\PY{p}{(}\PY{n}{t}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}81}]:} 4
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}82}]:} \PY{n+nb}{len}\PY{p}{(}\PY{n}{ages}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}82}]:} 3
\end{Verbatim}
            
    \subsubsection{Use of zip and dict}\label{use-of-zip-and-dict}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}65}]:} \PY{n}{A}\PY{o}{=} \PY{n+nb}{range} \PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}
         \PY{k}{print} \PY{n}{a}
         \PY{n}{B}\PY{o}{=}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{c}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
         \PY{n}{C}\PY{o}{=}\PY{n+nb}{dict}\PY{p}{(}\PY{n+nb}{zip}\PY{p}{(}\PY{n}{B}\PY{p}{,}\PY{n}{A}\PY{p}{)}\PY{p}{)}
         
         \PY{k}{print} \PY{n+nb}{zip}\PY{p}{(}\PY{n}{A}\PY{p}{,}\PY{n}{B}\PY{p}{)}
         \PY{k}{print} \PY{n+nb}{dict}\PY{p}{(}\PY{n+nb}{zip}\PY{p}{(}\PY{n}{B}\PY{p}{,}\PY{n}{A}\PY{p}{)}\PY{p}{)}
         
         \PY{k}{print} \PY{n}{C}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
[0, 1, 2]
[(0, 'a'), (1, 'b'), (2, 'c')]
\{'a': 0, 'c': 2, 'b': 1\}
1

    \end{Verbatim}

    \subsection{Plotting with Matplotlib}\label{plotting-with-matplotlib}

We can generally understand trends in data by using a plotting program
to chart it. Python has a wonderful plotting library called
\href{http://matplotlib.sf.net}{Matplotlib}. The IPython notebook
interface we are using for these notes has that functionality built in.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}66}]:} \PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k+kn}{as} \PY{n+nn}{np}
         \PY{n}{T1}\PY{o}{=}\PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{random}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)} \PY{c+c1}{\PYZsh{} a time serise}
         \PY{n}{T2}\PY{o}{=}\PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{random}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}73}]:} \PY{k+kn}{import} \PY{n+nn}{matplotlib.pyplot} \PY{k+kn}{as} \PY{n+nn}{plt}
         \PY{o}{\PYZpc{}}\PY{k}{matplotlib} inline
         \PY{c+c1}{\PYZsh{}figsize(8,6)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{T1}\PY{p}{,}\PY{n}{label}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{time serise\PYZhy{}1}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{T2}\PY{p}{,}\PY{n}{label}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{time serise\PYZhy{}1}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{xlabel}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Time}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{legend}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}73}]:} <matplotlib.legend.Legend at 0x7fe1d2b9e150>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_161_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    There are many more things you can do with Matplotlib. We'll be looking
at some of them in the sections to come. In the meantime, if you want an
idea of the different things you can do, look at the Matplotlib
\href{http://matplotlib.org/gallery.html}{Gallery}. Rob Johansson's
IPython notebook
\href{http://nbviewer.ipython.org/urls/raw.github.com/jrjohansson/scientific-python-lectures/master/Lecture-4-Matplotlib.ipynb}{Introduction
to Matplotlib} is also particularly good.

    \subsection{Conclusion of the Python
Overview}\label{conclusion-of-the-python-overview}

There is, of course, much more to the language than I've covered here.
I've tried to keep this brief enough so that you can jump in and start
using Python to simplify your life and work. My own experience in
learning new things is that the information doesn't "stick" unless you
try and use it for something in real life.

You will no doubt need to learn more as you go. I've listed several
other good references, including the
\href{http://docs.python.org/2/tutorial/}{Python Tutorial} and
\href{http://learnpythonthehardway.org/book/}{Learn Python the Hard
Way}. Additionally, now is a good time to start familiarizing yourself
with the \href{http://docs.python.org/2.7/}{Python Documentation}, and,
in particular, the
\href{http://docs.python.org/2.7/reference/index.html}{Python Language
Reference}.

Tim Peters, one of the earliest and most prolific Python contributors,
wrote the "Zen of Python", which can be accessed via the "import this"
command:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}87}]:} \PY{k+kn}{import} \PY{n+nn}{this}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!

    \end{Verbatim}

    No matter how experienced a programmer you are, these are words to
meditate on.

    \section{II. Numpy and Scipy}\label{ii.-numpy-and-scipy}

\href{http://numpy.org}{Numpy} contains core routines for doing fast
vector, matrix, and linear algebra-type operations in Python.
\href{http://scipy}{Scipy} contains additional routines for
optimization, special functions, and so on. Both contain modules written
in C and Fortran so that they're as fast as possible. Together, they
give Python roughly the same capability that the
\href{http://www.mathworks.com/products/matlab/}{Matlab} program offers.
(In fact, if you're an experienced Matlab user, there a
\href{http://www.scipy.org/NumPy_for_Matlab_Users}{guide to Numpy for
Matlab users} just for you.)

    There's also an \textbf{identity} command that behaves as you'd expect:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}94}]:} \PY{k+kn}{import} \PY{n+nn}{scipy}
         \PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k+kn}{as} \PY{n+nn}{np}
         \PY{n}{np}\PY{o}{.}\PY{n}{identity}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}94}]:} array([[1., 0., 0., 0.],
                [0., 1., 0., 0.],
                [0., 0., 1., 0.],
                [0., 0., 0., 1.]])
\end{Verbatim}
            
    as well as a \textbf{ones} command.

    \subsection{Linspace, matrix functions, and
plotting}\label{linspace-matrix-functions-and-plotting}

The \textbf{linspace} command makes a linear array of points from a
starting to an ending value.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}86}]:} \PY{n}{np}\PY{o}{.}\PY{n}{linspace}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}86}]:} array([0.        , 0.33333333, 0.66666667, 1.        ])
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}82}]:} \PY{n}{x} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linspace}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{np}\PY{o}{.}\PY{n}{pi}\PY{p}{)}
         \PY{n}{np}\PY{o}{.}\PY{n}{sin}\PY{p}{(}\PY{n}{x}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}82}]:} array([ 0.00000000e+00,  1.27877162e-01,  2.53654584e-01,  3.75267005e-01,
                 4.90717552e-01,  5.98110530e-01,  6.95682551e-01,  7.81831482e-01,
                 8.55142763e-01,  9.14412623e-01,  9.58667853e-01,  9.87181783e-01,
                 9.99486216e-01,  9.95379113e-01,  9.74927912e-01,  9.38468422e-01,
                 8.86599306e-01,  8.20172255e-01,  7.40277997e-01,  6.48228395e-01,
                 5.45534901e-01,  4.33883739e-01,  3.15108218e-01,  1.91158629e-01,
                 6.40702200e-02, -6.40702200e-02, -1.91158629e-01, -3.15108218e-01,
                -4.33883739e-01, -5.45534901e-01, -6.48228395e-01, -7.40277997e-01,
                -8.20172255e-01, -8.86599306e-01, -9.38468422e-01, -9.74927912e-01,
                -9.95379113e-01, -9.99486216e-01, -9.87181783e-01, -9.58667853e-01,
                -9.14412623e-01, -8.55142763e-01, -7.81831482e-01, -6.95682551e-01,
                -5.98110530e-01, -4.90717552e-01, -3.75267005e-01, -2.53654584e-01,
                -1.27877162e-01, -2.44929360e-16])
\end{Verbatim}
            
    In conjunction with \textbf{matplotlib}, this is a nice way to plot
things:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}83}]:} \PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{np}\PY{o}{.}\PY{n}{sin}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}83}]:} [<matplotlib.lines.Line2D at 0x7fe1d2b218d0>]
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_174_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \subsection{Matrix operations}\label{matrix-operations}

Matrix objects act sensibly when multiplied by scalars:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}102}]:} \PY{l+m+mf}{0.125}\PY{o}{*}\PY{n}{identity}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{d}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}102}]:} array([[ 0.125,  0.   ,  0.   ],
                 [ 0.   ,  0.125,  0.   ],
                 [ 0.   ,  0.   ,  0.125]])
\end{Verbatim}
            
    as well as when you add two matrices together. (However, the matrices
have to be the same shape.)

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}103}]:} \PY{n}{identity}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{d}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o}{+} \PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}103}]:} array([[ 2.,  1.],
                 [ 1.,  3.]])
\end{Verbatim}
            
    Something that confuses Matlab users is that the times (*) operator give
element-wise multiplication rather than matrix multiplication:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}104}]:} \PY{n}{identity}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{)}\PY{o}{*}\PY{n}{ones}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}104}]:} array([[ 1.,  0.],
                 [ 0.,  1.]])
\end{Verbatim}
            
    To get matrix multiplication, you need the \textbf{dot} command:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}105}]:} \PY{n}{dot}\PY{p}{(}\PY{n}{identity}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{,}\PY{n}{ones}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}105}]:} array([[ 1.,  1.],
                 [ 1.,  1.]])
\end{Verbatim}
            
    \textbf{dot} can also do dot products (duh!):

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}106}]:} \PY{n}{v} \PY{o}{=} \PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{]}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{d}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
          \PY{n}{sqrt}\PY{p}{(}\PY{n}{dot}\PY{p}{(}\PY{n}{v}\PY{p}{,}\PY{n}{v}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}106}]:} 5.0
\end{Verbatim}
            
    as well as matrix-vector products.

    There are \textbf{determinant}, \textbf{inverse}, and \textbf{transpose}
functions that act as you would suppose. Transpose can be abbreviated
with ".T" at the end of a matrix object:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}107}]:} \PY{n}{m} \PY{o}{=} \PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{]}\PY{p}{]}\PY{p}{)}
          \PY{n}{m}\PY{o}{.}\PY{n}{T}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}107}]:} array([[1, 3],
                 [2, 4]])
\end{Verbatim}
            
    There's also a \textbf{diag()} function that takes a list or a vector
and puts it along the diagonal of a square matrix.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}108}]:} \PY{n}{diag}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}108}]:} array([[1, 0, 0, 0, 0],
                 [0, 2, 0, 0, 0],
                 [0, 0, 3, 0, 0],
                 [0, 0, 0, 4, 0],
                 [0, 0, 0, 0, 5]])
\end{Verbatim}
            
    We'll find this useful later on.

    \subsection{Matrix Solvers}\label{matrix-solvers}

You can solve systems of linear equations using the \textbf{solve}
command:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}98}]:} \PY{n}{A} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{]}\PY{p}{,}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{]}\PY{p}{)}
         \PY{n}{b} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{6}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{27}\PY{p}{]}\PY{p}{)}
         \PY{n}{np}\PY{o}{.}\PY{n}{linalg}\PY{o}{.}\PY{n}{solve}\PY{p}{(}\PY{n}{A}\PY{p}{,} \PY{n}{b}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}98}]:} array([ 5.,  3., -2.])
\end{Verbatim}
            
    There are a number of routines to compute eigenvalues and eigenvectors

\begin{itemize}
\tightlist
\item
  \textbf{eigvals} returns the eigenvalues of a matrix
\item
  \textbf{eigvalsh} returns the eigenvalues of a Hermitian matrix
\item
  \textbf{eig} returns the eigenvalues and eigenvectors of a matrix
\item
  \textbf{eigh} returns the eigenvalues and eigenvectors of a Hermitian
  matrix.
\end{itemize}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}110}]:} \PY{n}{A} \PY{o}{=} \PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{13}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{4}\PY{p}{]}\PY{p}{,}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{7}\PY{p}{]}\PY{p}{]}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{d}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
          \PY{n}{eigvalsh}\PY{p}{(}\PY{n}{A}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}110}]:} array([  5.,  15.])
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}111}]:} \PY{n}{eigh}\PY{p}{(}\PY{n}{A}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}111}]:} (array([  5.,  15.]), array([[-0.4472136 , -0.89442719],
                  [-0.89442719,  0.4472136 ]]))
\end{Verbatim}
            
    \subsection{ Jump to "Functional programming"
}\label{jump-to-functional-programming}

    \subsection{Example: Finite
Differences}\label{example-finite-differences}

Now that we have these tools in our toolbox, we can start to do some
cool stuff with it. Many of the equations we want to solve in Physics
involve differential equations. We want to be able to compute the
derivative of functions:

\[ y' = \frac{y(x+h)-y(x)}{h} \]

by \emph{discretizing} the function \(y(x)\) on an evenly spaced set of
points \(x_0, x_1, \dots, x_n\), yielding \(y_0, y_1, \dots, y_n\).
Using the discretization, we can approximate the derivative by

\[ y_i' \approx \frac{y_{i+1}-y_{i-1}}{x_{i+1}-x_{i-1}} \]

We can write a derivative function in Python via

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}208}]:} \PY{k}{def} \PY{n+nf}{nderiv}\PY{p}{(}\PY{n}{y}\PY{p}{,}\PY{n}{x}\PY{p}{)}\PY{p}{:}
              \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Finite difference derivative of the function f}\PY{l+s+s2}{\PYZdq{}}
              \PY{n}{n} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{y}\PY{p}{)}
              \PY{n}{d} \PY{o}{=} \PY{n}{zeros}\PY{p}{(}\PY{n}{n}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{d}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{c+c1}{\PYZsh{} assume double}
              \PY{c+c1}{\PYZsh{} Use centered differences for the interior points, one\PYZhy{}sided differences for the ends}
              \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{n}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{:}
                  \PY{n}{d}\PY{p}{[}\PY{n}{i}\PY{p}{]} \PY{o}{=} \PY{p}{(}\PY{n}{y}\PY{p}{[}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{n}{y}\PY{p}{[}\PY{n}{i}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}\PY{o}{/}\PY{p}{(}\PY{n}{x}\PY{p}{[}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{n}{x}\PY{p}{[}\PY{n}{i}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
              \PY{n}{d}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]} \PY{o}{=} \PY{p}{(}\PY{n}{y}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{n}{y}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}\PY{o}{/}\PY{p}{(}\PY{n}{x}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{n}{x}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
              \PY{n}{d}\PY{p}{[}\PY{n}{n}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{=} \PY{p}{(}\PY{n}{y}\PY{p}{[}\PY{n}{n}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{n}{y}\PY{p}{[}\PY{n}{n}\PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}\PY{o}{/}\PY{p}{(}\PY{n}{x}\PY{p}{[}\PY{n}{n}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{n}{x}\PY{p}{[}\PY{n}{n}\PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}
              \PY{k}{return} \PY{n}{d}
\end{Verbatim}


    Let's see whether this works for our sin example from above:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}209}]:} \PY{n}{x} \PY{o}{=} \PY{n}{linspace}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{pi}\PY{p}{)}
          \PY{n}{dsin} \PY{o}{=} \PY{n}{nderiv}\PY{p}{(}\PY{n}{sin}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{,}\PY{n}{x}\PY{p}{)}
          \PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{dsin}\PY{p}{,}\PY{n}{label}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{numerical}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
          \PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{cos}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{,}\PY{n}{label}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{analytical}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
          \PY{n}{title}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Comparison of numerical and analytical derivatives of sin(x)}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
          \PY{n}{legend}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}209}]:} <matplotlib.legend.Legend at 0x110b39c10>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_200_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    Pretty close!

    \subsection{One-Dimensional Harmonic Oscillator using Finite
Difference}\label{one-dimensional-harmonic-oscillator-using-finite-difference}

Now that we've convinced ourselves that finite differences aren't a
terrible approximation, let's see if we can use this to solve the
one-dimensional harmonic oscillator.

We want to solve the time-independent Schrodinger equation

\[ -\frac{\hbar^2}{2m}\frac{\partial^2\psi(x)}{\partial x^2} + V(x)\psi(x) = E\psi(x)\]

for \(\psi(x)\) when \(V(x)=\frac{1}{2}m\omega^2x^2\) is the harmonic
oscillator potential. We're going to use the standard trick to transform
the differential equation into a matrix equation by multiplying both
sides by \(\psi^*(x)\) and integrating over \(x\). This yields

\[ -\frac{\hbar}{2m}\int\psi(x)\frac{\partial^2}{\partial x^2}\psi(x)dx + \int\psi(x)V(x)\psi(x)dx = E\]

We will again use the finite difference approximation. The finite
difference formula for the second derivative is

\[ y'' = \frac{y_{i+1}-2y_i+y_{i-1}}{x_{i+1}-x_{i-1}} \]

We can think of the first term in the Schrodinger equation as the
overlap of the wave function \(\psi(x)\) with the second derivative of
the wave function \(\frac{\partial^2}{\partial x^2}\psi(x)\). Given the
above expression for the second derivative, we can see if we take the
overlap of the states \(y_1,\dots,y_n\) with the second derivative, we
will only have three points where the overlap is nonzero, at
\(y_{i-1}\), \(y_i\), and \(y_{i+1}\). In matrix form, this leads to the
tridiagonal Laplacian matrix, which has -2's along the diagonals, and
1's along the diagonals above and below the main diagonal.

The second term turns leads to a diagonal matrix with \(V(x_i)\) on the
diagonal elements. Putting all of these pieces together, we get:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}114}]:} \PY{k}{def} \PY{n+nf}{Laplacian}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
              \PY{n}{h} \PY{o}{=} \PY{n}{x}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{n}{x}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]} \PY{c+c1}{\PYZsh{} assume uniformly spaced points}
              \PY{n}{n} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{x}\PY{p}{)}
              \PY{n}{M} \PY{o}{=} \PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{identity}\PY{p}{(}\PY{n}{n}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{d}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
              \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{n}\PY{p}{)}\PY{p}{:}
                  \PY{n}{M}\PY{p}{[}\PY{n}{i}\PY{p}{,}\PY{n}{i}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{=} \PY{n}{M}\PY{p}{[}\PY{n}{i}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{i}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{1}
              \PY{k}{return} \PY{n}{M}\PY{o}{/}\PY{n}{h}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}115}]:} \PY{n}{x} \PY{o}{=} \PY{n}{linspace}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{)}
          \PY{n}{m} \PY{o}{=} \PY{l+m+mf}{1.0}
          \PY{n}{ohm} \PY{o}{=} \PY{l+m+mf}{1.0}
          \PY{n}{T} \PY{o}{=} \PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mf}{0.5}\PY{o}{/}\PY{n}{m}\PY{p}{)}\PY{o}{*}\PY{n}{Laplacian}\PY{p}{(}\PY{n}{x}\PY{p}{)}
          \PY{n}{V} \PY{o}{=} \PY{l+m+mf}{0.5}\PY{o}{*}\PY{p}{(}\PY{n}{ohm}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{p}{)}\PY{o}{*}\PY{p}{(}\PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{p}{)}
          \PY{n}{H} \PY{o}{=}  \PY{n}{T} \PY{o}{+} \PY{n}{diag}\PY{p}{(}\PY{n}{V}\PY{p}{)}
          \PY{n}{E}\PY{p}{,}\PY{n}{U} \PY{o}{=} \PY{n}{eigh}\PY{p}{(}\PY{n}{H}\PY{p}{)}
          \PY{n}{h} \PY{o}{=} \PY{n}{x}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{n}{x}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
          
          \PY{c+c1}{\PYZsh{} Plot the Harmonic potential}
          \PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{V}\PY{p}{,}\PY{n}{color}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{k}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
          
          \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}\PY{p}{:}
              \PY{c+c1}{\PYZsh{} For each of the first few solutions, plot the energy level:}
              \PY{n}{axhline}\PY{p}{(}\PY{n}{y}\PY{o}{=}\PY{n}{E}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{,}\PY{n}{color}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{k}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{n}{ls}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
              \PY{c+c1}{\PYZsh{} as well as the eigenfunction, displaced by the energy level so they don\PYZsq{}t}
              \PY{c+c1}{\PYZsh{} all pile up on each other:}
              \PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{n}{U}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{n}{i}\PY{p}{]}\PY{o}{/}\PY{n}{sqrt}\PY{p}{(}\PY{n}{h}\PY{p}{)}\PY{o}{+}\PY{n}{E}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)}
          \PY{n}{title}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Eigenfunctions of the Quantum Harmonic Oscillator}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
          \PY{n}{xlabel}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Displacement (bohr)}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
          \PY{n}{ylabel}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Energy (hartree)}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}115}]:} <matplotlib.text.Text at 0x10d7b9650>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_204_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    We've made a couple of hacks here to get the orbitals the way we want
them. First, I inserted a -1 factor before the wave functions, to fix
the phase of the lowest state. The phase (sign) of a quantum wave
function doesn't hold any information, only the square of the wave
function does, so this doesn't really change anything.

But the eigenfunctions as we generate them aren't properly normalized.
The reason is that finite difference isn't a real basis in the quantum
mechanical sense. It's a basis of Dirac δ functions at each point; we
interpret the space betwen the points as being "filled" by the wave
function, but the finite difference basis only has the solution being at
the points themselves. We can fix this by dividing the eigenfunctions of
our finite difference Hamiltonian by the square root of the spacing, and
this gives properly normalized functions.

    \subsection{Special Functions}\label{special-functions}

The solutions to the Harmonic Oscillator are supposed to be Hermite
polynomials. The Wikipedia page has the HO states given by

\[\psi_n(x) = \frac{1}{\sqrt{2^n n!}}
\left(\frac{m\omega}{\pi\hbar}\right)^{1/4}
\exp\left(-\frac{m\omega x^2}{2\hbar}\right)
H_n\left(\sqrt{\frac{m\omega}{\hbar}}x\right)\]

Let's see whether they look like those. There are some special functions
in the Numpy library, and some more in Scipy. Hermite Polynomials are in
Numpy:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}116}]:} \PY{k+kn}{from} \PY{n+nn}{numpy.polynomial.hermite} \PY{k+kn}{import} \PY{n}{Hermite}
          \PY{k}{def} \PY{n+nf}{ho\PYZus{}evec}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{n}\PY{p}{,}\PY{n}{m}\PY{p}{,}\PY{n}{ohm}\PY{p}{)}\PY{p}{:}
              \PY{n}{vec} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{*}\PY{l+m+mi}{9}
              \PY{n}{vec}\PY{p}{[}\PY{n}{n}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{1}
              \PY{n}{Hn} \PY{o}{=} \PY{n}{Hermite}\PY{p}{(}\PY{n}{vec}\PY{p}{)}
              \PY{k}{return} \PY{p}{(}\PY{l+m+mi}{1}\PY{o}{/}\PY{n}{sqrt}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{*}\PY{o}{*}\PY{n}{n}\PY{o}{*}\PY{n}{factorial}\PY{p}{(}\PY{n}{n}\PY{p}{)}\PY{p}{)}\PY{p}{)}\PY{o}{*}\PY{n+nb}{pow}\PY{p}{(}\PY{n}{m}\PY{o}{*}\PY{n}{ohm}\PY{o}{/}\PY{n}{pi}\PY{p}{,}\PY{l+m+mf}{0.25}\PY{p}{)}\PY{o}{*}\PY{n}{exp}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mf}{0.5}\PY{o}{*}\PY{n}{m}\PY{o}{*}\PY{n}{ohm}\PY{o}{*}\PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{p}{)}\PY{o}{*}\PY{n}{Hn}\PY{p}{(}\PY{n}{x}\PY{o}{*}\PY{n}{sqrt}\PY{p}{(}\PY{n}{m}\PY{o}{*}\PY{n}{ohm}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    Let's compare the first function to our solution.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}117}]:} \PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{ho\PYZus{}evec}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{,}\PY{n}{label}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Analytic}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
          \PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{n}{U}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{/}\PY{n}{sqrt}\PY{p}{(}\PY{n}{h}\PY{p}{)}\PY{p}{,}\PY{n}{label}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Numeric}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
          \PY{n}{xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{x (bohr)}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
          \PY{n}{ylabel}\PY{p}{(}\PY{l+s+sa}{r}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZdl{}}\PY{l+s+s1}{\PYZbs{}}\PY{l+s+s1}{psi(x)\PYZdl{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
          \PY{n}{title}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Comparison of numeric and analytic solutions to the Harmonic Oscillator}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
          \PY{n}{legend}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}117}]:} <matplotlib.legend.Legend at 0x10da6b950>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_209_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    The agreement is almost exact.

    We can use the \textbf{subplot} command to put multiple comparisons in
different panes on a single plot:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}118}]:} \PY{n}{phase\PYZus{}correction} \PY{o}{=} \PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}
          \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{:}
              \PY{n}{subplot}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{,}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}
              \PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{ho\PYZus{}evec}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{i}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{,}\PY{n}{label}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Analytic}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
              \PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{phase\PYZus{}correction}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{o}{*}\PY{n}{U}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{n}{i}\PY{p}{]}\PY{o}{/}\PY{n}{sqrt}\PY{p}{(}\PY{n}{h}\PY{p}{)}\PY{p}{,}\PY{n}{label}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Numeric}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_212_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    Other than phase errors (which I've corrected with a little hack: can
you find it?), the agreement is pretty good, although it gets worse the
higher in energy we get, in part because we used only 50 points.

The Scipy module has many more special functions:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}119}]:} \PY{k+kn}{from} \PY{n+nn}{scipy.special} \PY{k+kn}{import} \PY{n}{airy}\PY{p}{,}\PY{n}{jn}\PY{p}{,}\PY{n}{eval\PYZus{}chebyt}\PY{p}{,}\PY{n}{eval\PYZus{}legendre}
          \PY{n}{subplot}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
          \PY{n}{x} \PY{o}{=} \PY{n}{linspace}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
          \PY{n}{Ai}\PY{p}{,}\PY{n}{Aip}\PY{p}{,}\PY{n}{Bi}\PY{p}{,}\PY{n}{Bip} \PY{o}{=} \PY{n}{airy}\PY{p}{(}\PY{n}{x}\PY{p}{)}
          \PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{Ai}\PY{p}{)}
          \PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{Aip}\PY{p}{)}
          \PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{Bi}\PY{p}{)}
          \PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{Bip}\PY{p}{)}
          \PY{n}{title}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Airy functions}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
          
          \PY{n}{subplot}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}
          \PY{n}{x} \PY{o}{=} \PY{n}{linspace}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{10}\PY{p}{)}
          \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}\PY{p}{:}
              \PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{jn}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{x}\PY{p}{)}\PY{p}{)}
          \PY{n}{title}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Bessel functions}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
          
          \PY{n}{subplot}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{)}
          \PY{n}{x} \PY{o}{=} \PY{n}{linspace}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
          \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{:}
              \PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{eval\PYZus{}chebyt}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{x}\PY{p}{)}\PY{p}{)}
          \PY{n}{title}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Chebyshev polynomials of the first kind}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
          
          \PY{n}{subplot}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{)}
          \PY{n}{x} \PY{o}{=} \PY{n}{linspace}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
          \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{:}
              \PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{eval\PYZus{}legendre}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{x}\PY{p}{)}\PY{p}{)}
          \PY{n}{title}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Legendre polynomials}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}119}]:} <matplotlib.text.Text at 0x10e809c50>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_214_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    As well as Jacobi, Laguerre, Hermite polynomials, Hypergeometric
functions, and many others. There's a full listing at the
\href{http://docs.scipy.org/doc/scipy/reference/special.html}{Scipy
Special Functions Page}.

    \subsection{Least squares fitting}\label{least-squares-fitting}

Very often we deal with some data that we want to fit to some sort of
expected behavior. Say we have the following:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}120}]:} \PY{n}{raw\PYZus{}data} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{l+s+se}{\PYZbs{}}
          \PY{l+s+s2}{3.1905781584582433,0.028208609537968457}
          \PY{l+s+s2}{4.346895074946466,0.007160804747670053}
          \PY{l+s+s2}{5.374732334047101,0.0046962988461934805}
          \PY{l+s+s2}{8.201284796573875,0.0004614473299618756}
          \PY{l+s+s2}{10.899357601713055,0.00005038370219939726}
          \PY{l+s+s2}{16.295503211991434,4.377451812785309e\PYZhy{}7}
          \PY{l+s+s2}{21.82012847965739,3.0799922117601088e\PYZhy{}9}
          \PY{l+s+s2}{32.48394004282656,1.524776208284536e\PYZhy{}13}
          \PY{l+s+s2}{43.53319057815846,5.5012073588707224e\PYZhy{}18}\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
\end{Verbatim}


    There's a section below on parsing CSV data. We'll steal the parser from
that. For an explanation, skip ahead to that section. Otherwise, just
assume that this is a way to parse that text into a numpy array that we
can plot and do other analyses with.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}121}]:} \PY{n}{data} \PY{o}{=} \PY{p}{[}\PY{p}{]}
          \PY{k}{for} \PY{n}{line} \PY{o+ow}{in} \PY{n}{raw\PYZus{}data}\PY{o}{.}\PY{n}{splitlines}\PY{p}{(}\PY{p}{)}\PY{p}{:}
              \PY{n}{words} \PY{o}{=} \PY{n}{line}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{,}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
              \PY{n}{data}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n+nb}{map}\PY{p}{(}\PY{n+nb}{float}\PY{p}{,}\PY{n}{words}\PY{p}{)}\PY{p}{)}
          \PY{n}{data} \PY{o}{=} \PY{n}{array}\PY{p}{(}\PY{n}{data}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}122}]:} \PY{n}{title}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Raw Data}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
          \PY{n}{xlabel}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Distance}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
          \PY{n}{plot}\PY{p}{(}\PY{n}{data}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{data}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bo}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}122}]:} [<matplotlib.lines.Line2D at 0x10e70dc90>]
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_220_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    Since we expect the data to have an exponential decay, we can plot it
using a semi-log plot.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}123}]:} \PY{n}{title}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Raw Data}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
          \PY{n}{xlabel}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Distance}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
          \PY{n}{semilogy}\PY{p}{(}\PY{n}{data}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{data}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bo}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}123}]:} [<matplotlib.lines.Line2D at 0x10dfc6fd0>]
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_222_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    For a pure exponential decay like this, we can fit the log of the data
to a straight line. The above plot suggests this is a good
approximation. Given a function \[ y = Ae^{-ax} \]
\[ \log(y) = \log(A) - ax\] Thus, if we fit the log of the data versus
x, we should get a straight line with slope \(a\), and an intercept that
gives the constant \(A\).

There's a numpy function called \textbf{polyfit} that will fit data to a
polynomial form. We'll use this to fit to a straight line (a polynomial
of order 1)

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}124}]:} \PY{n}{params} \PY{o}{=} \PY{n}{polyfit}\PY{p}{(}\PY{n}{data}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{log}\PY{p}{(}\PY{n}{data}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
          \PY{n}{a} \PY{o}{=} \PY{n}{params}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
          \PY{n}{A} \PY{o}{=} \PY{n}{exp}\PY{p}{(}\PY{n}{params}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    Let's see whether this curve fits the data.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}125}]:} \PY{n}{x} \PY{o}{=} \PY{n}{linspace}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{45}\PY{p}{)}
          \PY{n}{title}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Raw Data}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
          \PY{n}{xlabel}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Distance}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
          \PY{n}{semilogy}\PY{p}{(}\PY{n}{data}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{data}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bo}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
          \PY{n}{semilogy}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{A}\PY{o}{*}\PY{n}{exp}\PY{p}{(}\PY{n}{a}\PY{o}{*}\PY{n}{x}\PY{p}{)}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b\PYZhy{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}125}]:} [<matplotlib.lines.Line2D at 0x10dcdffd0>]
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_226_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    If we have more complicated functions, we may not be able to get away
with fitting to a simple polynomial. Consider the following data:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}126}]:} \PY{n}{gauss\PYZus{}data} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{l+s+se}{\PYZbs{}}
          \PY{l+s+s2}{\PYZhy{}0.9902286902286903,1.4065274110372852e\PYZhy{}19}
          \PY{l+s+s2}{\PYZhy{}0.7566104566104566,2.2504438576596563e\PYZhy{}18}
          \PY{l+s+s2}{\PYZhy{}0.5117810117810118,1.9459459459459454}
          \PY{l+s+s2}{\PYZhy{}0.31887271887271884,10.621621621621626}
          \PY{l+s+s2}{\PYZhy{}0.250997150997151,15.891891891891893}
          \PY{l+s+s2}{\PYZhy{}0.1463309463309464,23.756756756756754}
          \PY{l+s+s2}{\PYZhy{}0.07267267267267263,28.135135135135133}
          \PY{l+s+s2}{\PYZhy{}0.04426734426734419,29.02702702702703}
          \PY{l+s+s2}{\PYZhy{}0.0015939015939017698,29.675675675675677}
          \PY{l+s+s2}{0.04689304689304685,29.10810810810811}
          \PY{l+s+s2}{0.0840994840994842,27.324324324324326}
          \PY{l+s+s2}{0.1700546700546699,22.216216216216214}
          \PY{l+s+s2}{0.370878570878571,7.540540540540545}
          \PY{l+s+s2}{0.5338338338338338,1.621621621621618}
          \PY{l+s+s2}{0.722014322014322,0.08108108108108068}
          \PY{l+s+s2}{0.9926849926849926,\PYZhy{}0.08108108108108646}\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
          
          \PY{n}{data} \PY{o}{=} \PY{p}{[}\PY{p}{]}
          \PY{k}{for} \PY{n}{line} \PY{o+ow}{in} \PY{n}{gauss\PYZus{}data}\PY{o}{.}\PY{n}{splitlines}\PY{p}{(}\PY{p}{)}\PY{p}{:}
              \PY{n}{words} \PY{o}{=} \PY{n}{line}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{,}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
              \PY{n}{data}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n+nb}{map}\PY{p}{(}\PY{n+nb}{float}\PY{p}{,}\PY{n}{words}\PY{p}{)}\PY{p}{)}
          \PY{n}{data} \PY{o}{=} \PY{n}{array}\PY{p}{(}\PY{n}{data}\PY{p}{)}
          
          \PY{n}{plot}\PY{p}{(}\PY{n}{data}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{data}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bo}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}126}]:} [<matplotlib.lines.Line2D at 0x10ddecc90>]
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_228_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    This data looks more Gaussian than exponential. If we wanted to, we
could use \textbf{polyfit} for this as well, but let's use the
\textbf{curve\_fit} function from Scipy, which can fit to arbitrary
functions. You can learn more using help(curve\_fit).

First define a general Gaussian function to fit to.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}127}]:} \PY{k}{def} \PY{n+nf}{gauss}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{A}\PY{p}{,}\PY{n}{a}\PY{p}{)}\PY{p}{:} \PY{k}{return} \PY{n}{A}\PY{o}{*}\PY{n}{exp}\PY{p}{(}\PY{n}{a}\PY{o}{*}\PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{p}{)}
\end{Verbatim}


    Now fit to it using \textbf{curve\_fit}:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}128}]:} \PY{k+kn}{from} \PY{n+nn}{scipy.optimize} \PY{k+kn}{import} \PY{n}{curve\PYZus{}fit}
          
          \PY{n}{params}\PY{p}{,}\PY{n}{conv} \PY{o}{=} \PY{n}{curve\PYZus{}fit}\PY{p}{(}\PY{n}{gauss}\PY{p}{,}\PY{n}{data}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{data}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
          \PY{n}{x} \PY{o}{=} \PY{n}{linspace}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
          \PY{n}{plot}\PY{p}{(}\PY{n}{data}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{data}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bo}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
          \PY{n}{A}\PY{p}{,}\PY{n}{a} \PY{o}{=} \PY{n}{params}
          \PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{gauss}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{A}\PY{p}{,}\PY{n}{a}\PY{p}{)}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b\PYZhy{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}128}]:} [<matplotlib.lines.Line2D at 0x10f86a110>]
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_232_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    The \textbf{curve\_fit} routine we just used is built on top of a very
good general \textbf{minimization} capability in Scipy. You can learn
more
\href{http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html}{at
the scipy documentation pages}.

    \subsection{\texorpdfstring{Monte Carlo, random numbers, and computing
\(\pi\)}{Monte Carlo, random numbers, and computing \textbackslash{}pi}}\label{monte-carlo-random-numbers-and-computing-pi}

Many methods in scientific computing rely on Monte Carlo integration,
where a sequence of (pseudo) random numbers are used to approximate the
integral of a function. Python has good random number generators in the
standard library. The \textbf{random()} function gives pseudorandom
numbers uniformly distributed between 0 and 1:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}129}]:} \PY{k+kn}{from} \PY{n+nn}{random} \PY{k+kn}{import} \PY{n}{random}
          \PY{n}{rands} \PY{o}{=} \PY{p}{[}\PY{p}{]}
          \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{100}\PY{p}{)}\PY{p}{:}
              \PY{n}{rands}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{random}\PY{p}{(}\PY{p}{)}\PY{p}{)}
          \PY{n}{plot}\PY{p}{(}\PY{n}{rands}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}129}]:} [<matplotlib.lines.Line2D at 0x10f9bf210>]
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_235_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \textbf{random()} uses the
\href{http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html}{Mersenne
Twister} algorithm, which is a highly regarded pseudorandom number
generator. There are also functions to generate random integers, to
randomly shuffle a list, and functions to pick random numbers from a
particular distribution, like the normal distribution:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}130}]:} \PY{k+kn}{from} \PY{n+nn}{random} \PY{k+kn}{import} \PY{n}{gauss}
          \PY{n}{grands} \PY{o}{=} \PY{p}{[}\PY{p}{]}
          \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{100}\PY{p}{)}\PY{p}{:}
              \PY{n}{grands}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{gauss}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}
          \PY{n}{plot}\PY{p}{(}\PY{n}{grands}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}130}]:} [<matplotlib.lines.Line2D at 0x10fb08910>]
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_237_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    It is generally more efficient to generate a list of random numbers all
at once, particularly if you're drawing from a non-uniform distribution.
Numpy has functions to generate vectors and matrices of particular types
of random distributions.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}131}]:} \PY{n}{plot}\PY{p}{(}\PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{100}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}131}]:} [<matplotlib.lines.Line2D at 0x10fc69a50>]
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_239_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    One of the first programs I ever wrote was a program to compute \(\pi\)
by taking random numbers as x and y coordinates, and counting how many
of them were in the unit circle. For example:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}132}]:} \PY{n}{npts} \PY{o}{=} \PY{l+m+mi}{5000}
          \PY{n}{xs} \PY{o}{=} \PY{l+m+mi}{2}\PY{o}{*}\PY{n}{rand}\PY{p}{(}\PY{n}{npts}\PY{p}{)}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}
          \PY{n}{ys} \PY{o}{=} \PY{l+m+mi}{2}\PY{o}{*}\PY{n}{rand}\PY{p}{(}\PY{n}{npts}\PY{p}{)}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}
          \PY{n}{r} \PY{o}{=} \PY{n}{xs}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{o}{+}\PY{n}{ys}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}
          \PY{n}{ninside} \PY{o}{=} \PY{p}{(}\PY{n}{r}\PY{o}{\PYZlt{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{p}{)}
          \PY{n}{figsize}\PY{p}{(}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{)} \PY{c+c1}{\PYZsh{} make the figure square}
          \PY{n}{title}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Approximation to pi = }\PY{l+s+si}{\PYZpc{}f}\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{p}{(}\PY{l+m+mi}{4}\PY{o}{*}\PY{n}{ninside}\PY{o}{/}\PY{n+nb}{float}\PY{p}{(}\PY{n}{npts}\PY{p}{)}\PY{p}{)}\PY{p}{)}
          \PY{n}{plot}\PY{p}{(}\PY{n}{xs}\PY{p}{[}\PY{n}{r}\PY{o}{\PYZlt{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{n}{ys}\PY{p}{[}\PY{n}{r}\PY{o}{\PYZlt{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b.}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
          \PY{n}{plot}\PY{p}{(}\PY{n}{xs}\PY{p}{[}\PY{n}{r}\PY{o}{\PYZgt{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{n}{ys}\PY{p}{[}\PY{n}{r}\PY{o}{\PYZgt{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{r.}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
          \PY{n}{figsize}\PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{)} \PY{c+c1}{\PYZsh{} change the figsize back to 4x3 for the rest of the notebook}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_241_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    The idea behind the program is that the ratio of the area of the unit
circle to the square that inscribes it is \(\pi/4\), so by counting the
fraction of the random points in the square that are inside the circle,
we get increasingly good estimates to \(\pi\).

The above code uses some higher level Numpy tricks to compute the radius
of each point in a single line, to count how many radii are below one in
a single line, and to filter the x,y points based on their radii. To be
honest, I rarely write code like this: I find some of these Numpy tricks
a little too cute to remember them, and I'm more likely to use a list
comprehension (see below) to filter the points I want, since I can
remember that.

As methods of computing \(\pi\) go, this is among the worst. A much
better method is to use Leibniz's expansion of arctan(1):

\[\frac{\pi}{4} = \sum_k \frac{(-1)^k}{2*k+1}\]

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}133}]:} \PY{n}{n} \PY{o}{=} \PY{l+m+mi}{100}
          \PY{n}{total} \PY{o}{=} \PY{l+m+mi}{0}
          \PY{k}{for} \PY{n}{k} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{n}\PY{p}{)}\PY{p}{:}
              \PY{n}{total} \PY{o}{+}\PY{o}{=} \PY{n+nb}{pow}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{k}\PY{p}{)}\PY{o}{/}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{k}\PY{o}{+}\PY{l+m+mf}{1.0}\PY{p}{)}
          \PY{k}{print} \PY{l+m+mi}{4}\PY{o}{*}\PY{n}{total}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
3.13159290356

    \end{Verbatim}

    If you're interested a great method, check out
\href{http://en.wikipedia.org/wiki/Approximations_of_\%CF\%80}{Ramanujan's
method}. This converges so fast you really need arbitrary precision math
to display enough decimal places. You can do this with the Python
\textbf{decimal} module, if you're interested.

    \subsection{Numerical Integration}\label{numerical-integration}

Integration can be hard, and sometimes it's easier to work out a
definite integral using an approximation. For example, suppose we wanted
to figure out the integral:

\[\int_0^\infty\exp(-x)dx=1\]

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}134}]:} \PY{k+kn}{from} \PY{n+nn}{numpy} \PY{k+kn}{import} \PY{n}{sqrt}
          \PY{k}{def} \PY{n+nf}{f}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:} \PY{k}{return} \PY{n}{exp}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{n}{x}\PY{p}{)}
          \PY{n}{x} \PY{o}{=} \PY{n}{linspace}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{10}\PY{p}{)}
          \PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{exp}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{n}{x}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}134}]:} [<matplotlib.lines.Line2D at 0x10ff00490>]
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_246_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    Scipy has a numerical integration routine \textbf{quad} (since sometimes
numerical integration is called \emph{quadrature}), that we can use for
this:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}135}]:} \PY{k+kn}{from} \PY{n+nn}{scipy.integrate} \PY{k+kn}{import} \PY{n}{quad}
          \PY{n}{quad}\PY{p}{(}\PY{n}{f}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{n}{inf}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}135}]:} (1.0000000000000002, 5.842606742906004e-11)
\end{Verbatim}
            
    There are also 2d and 3d numerical integrators in Scipy.
\href{http://docs.scipy.org/doc/scipy/reference/integrate.html}{See the
docs} for more information.

    \section{III. Intermediate Python}\label{iii.-intermediate-python}

\subsection{Output Parsing}\label{output-parsing}

As more and more of our day-to-day work is being done on and through
computers, we increasingly have output that one program writes, often in
a text file, that we need to analyze in one way or another, and
potentially feed that output into another file.

Suppose we have the following output:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}137}]:} \PY{n}{myoutput} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{l+s+se}{\PYZbs{}}
          \PY{l+s+s2}{@ Step       Energy      Delta E   Gmax     Grms     Xrms     Xmax   Walltime}
          \PY{l+s+s2}{@ \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{} \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{} \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{} \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{} \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{} \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{} \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{} \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
          \PY{l+s+s2}{@    0   \PYZhy{}6095.12544083  0.0D+00  0.03686  0.00936  0.00000  0.00000   1391.5}
          \PY{l+s+s2}{@    1   \PYZhy{}6095.25762870 \PYZhy{}1.3D\PYZhy{}01  0.00732  0.00168  0.32456  0.84140  10468.0}
          \PY{l+s+s2}{@    2   \PYZhy{}6095.26325979 \PYZhy{}5.6D\PYZhy{}03  0.00233  0.00056  0.06294  0.14009  11963.5}
          \PY{l+s+s2}{@    3   \PYZhy{}6095.26428124 \PYZhy{}1.0D\PYZhy{}03  0.00109  0.00024  0.03245  0.10269  13331.9}
          \PY{l+s+s2}{@    4   \PYZhy{}6095.26463203 \PYZhy{}3.5D\PYZhy{}04  0.00057  0.00013  0.02737  0.09112  14710.8}
          \PY{l+s+s2}{@    5   \PYZhy{}6095.26477615 \PYZhy{}1.4D\PYZhy{}04  0.00043  0.00009  0.02259  0.08615  20211.1}
          \PY{l+s+s2}{@    6   \PYZhy{}6095.26482624 \PYZhy{}5.0D\PYZhy{}05  0.00015  0.00002  0.00831  0.03147  21726.1}
          \PY{l+s+s2}{@    7   \PYZhy{}6095.26483584 \PYZhy{}9.6D\PYZhy{}06  0.00021  0.00004  0.01473  0.05265  24890.5}
          \PY{l+s+s2}{@    8   \PYZhy{}6095.26484405 \PYZhy{}8.2D\PYZhy{}06  0.00005  0.00001  0.00555  0.01929  26448.7}
          \PY{l+s+s2}{@    9   \PYZhy{}6095.26484599 \PYZhy{}1.9D\PYZhy{}06  0.00003  0.00001  0.00164  0.00564  27258.1}
          \PY{l+s+s2}{@   10   \PYZhy{}6095.26484676 \PYZhy{}7.7D\PYZhy{}07  0.00003  0.00001  0.00161  0.00553  28155.3}
          \PY{l+s+s2}{@   11   \PYZhy{}6095.26484693 \PYZhy{}1.8D\PYZhy{}07  0.00002  0.00000  0.00054  0.00151  28981.7}
          \PY{l+s+s2}{@   11   \PYZhy{}6095.26484693 \PYZhy{}1.8D\PYZhy{}07  0.00002  0.00000  0.00054  0.00151  28981.7}\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
\end{Verbatim}


    This output actually came from a geometry optimization of a Silicon
cluster using the
\href{http://www.nwchem-sw.org/index.php/Main_Page}{NWChem} quantum
chemistry suite. At every step the program computes the energy of the
molecular geometry, and then changes the geometry to minimize the
computed forces, until the energy converges. I obtained this output via
the unix command

\begin{verbatim}
% grep @ nwchem.out
\end{verbatim}

since NWChem is nice enough to precede the lines that you need to
monitor job progress with the '@' symbol.

We could do the entire analysis in Python; I'll show how to do this
later on, but first let's focus on turning this code into a usable
Python object that we can plot.

First, note that the data is entered into a multi-line string. When
Python sees three quote marks """ or ''' it treats everything following
as part of a single string, including newlines, tabs, and anything else,
until it sees the same three quote marks (""" has to be followed by
another """, and ''' has to be followed by another ''') again. This is a
convenient way to quickly dump data into Python, and it also reinforces
the important idea that you don't have to open a file and deal with it
one line at a time. You can read everything in, and deal with it as one
big chunk.

The first thing we'll do, though, is to split the big string into a list
of strings, since each line corresponds to a separate piece of data. We
will use the \textbf{splitlines()} function on the big myout string to
break it into a new element every time it sees a newline (\n) character:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}138}]:} \PY{n}{lines} \PY{o}{=} \PY{n}{myoutput}\PY{o}{.}\PY{n}{splitlines}\PY{p}{(}\PY{p}{)}
          \PY{n}{lines}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}138}]:} ['@ Step       Energy      Delta E   Gmax     Grms     Xrms     Xmax   Walltime',
           '@ ---- ---------------- -------- -------- -------- -------- -------- --------',
           '@    0   -6095.12544083  0.0D+00  0.03686  0.00936  0.00000  0.00000   1391.5',
           '@    1   -6095.25762870 -1.3D-01  0.00732  0.00168  0.32456  0.84140  10468.0',
           '@    2   -6095.26325979 -5.6D-03  0.00233  0.00056  0.06294  0.14009  11963.5',
           '@    3   -6095.26428124 -1.0D-03  0.00109  0.00024  0.03245  0.10269  13331.9',
           '@    4   -6095.26463203 -3.5D-04  0.00057  0.00013  0.02737  0.09112  14710.8',
           '@    5   -6095.26477615 -1.4D-04  0.00043  0.00009  0.02259  0.08615  20211.1',
           '@    6   -6095.26482624 -5.0D-05  0.00015  0.00002  0.00831  0.03147  21726.1',
           '@    7   -6095.26483584 -9.6D-06  0.00021  0.00004  0.01473  0.05265  24890.5',
           '@    8   -6095.26484405 -8.2D-06  0.00005  0.00001  0.00555  0.01929  26448.7',
           '@    9   -6095.26484599 -1.9D-06  0.00003  0.00001  0.00164  0.00564  27258.1',
           '@   10   -6095.26484676 -7.7D-07  0.00003  0.00001  0.00161  0.00553  28155.3',
           '@   11   -6095.26484693 -1.8D-07  0.00002  0.00000  0.00054  0.00151  28981.7',
           '@   11   -6095.26484693 -1.8D-07  0.00002  0.00000  0.00054  0.00151  28981.7']
\end{Verbatim}
            
    Splitting is a big concept in text processing. We used
\textbf{splitlines()} here, and we will use the more general
\textbf{split()} function below to split each line into
whitespace-delimited words.

We now want to do three things:

\begin{itemize}
\tightlist
\item
  Skip over the lines that don't carry any information
\item
  Break apart each line that does carry information and grab the pieces
  we want
\item
  Turn the resulting data into something that we can plot.
\end{itemize}

For this data, we really only want the Energy column, the Gmax column
(which contains the maximum gradient at each step), and perhaps the
Walltime column.

Since the data is now in a list of lines, we can iterate over it:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}139}]:} \PY{k}{for} \PY{n}{line} \PY{o+ow}{in} \PY{n}{lines}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{:}\PY{p}{]}\PY{p}{:}
              \PY{c+c1}{\PYZsh{} do something with each line}
              \PY{n}{words} \PY{o}{=} \PY{n}{line}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    Let's examine what we just did: first, we used a \textbf{for} loop to
iterate over each line. However, we skipped the first two (the
lines{[}2:{]} only takes the lines starting from index 2), since
lines{[}0{]} contained the title information, and lines{[}1{]} contained
underscores.

We then split each line into chunks (which we're calling "words", even
though in most cases they're numbers) using the string \textbf{split()}
command. Here's what split does:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}140}]:} \PY{k+kn}{import} \PY{n+nn}{string}
          \PY{n}{help}\PY{p}{(}\PY{n}{string}\PY{o}{.}\PY{n}{split}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Help on function split in module string:

split(s, sep=None, maxsplit=-1)
    split(s [,sep [,maxsplit]]) -> list of strings
    
    Return a list of the words in the string s, using sep as the
    delimiter string.  If maxsplit is given, splits at no more than
    maxsplit places (resulting in at most maxsplit+1 words).  If sep
    is not specified or is None, any whitespace string is a separator.
    
    (split and splitfields are synonymous)


    \end{Verbatim}

    Here we're implicitly passing in the first argument (s, in the doctext)
by calling a method .split() on a string object. In this instance, we're
not passing in a sep character, which means that the function splits on
whitespace. Let's see what that does to one of our lines:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}141}]:} \PY{n}{lines}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}141}]:} ['@',
           '0',
           '-6095.12544083',
           '0.0D+00',
           '0.03686',
           '0.00936',
           '0.00000',
           '0.00000',
           '1391.5']
\end{Verbatim}
            
    This is almost exactly what we want. We just have to now pick the fields
we want:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}142}]:} \PY{k}{for} \PY{n}{line} \PY{o+ow}{in} \PY{n}{lines}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{:}\PY{p}{]}\PY{p}{:}
              \PY{c+c1}{\PYZsh{} do something with each line}
              \PY{n}{words} \PY{o}{=} \PY{n}{line}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{p}{)}
              \PY{n}{energy} \PY{o}{=} \PY{n}{words}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}
              \PY{n}{gmax} \PY{o}{=} \PY{n}{words}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{]}
              \PY{n}{time} \PY{o}{=} \PY{n}{words}\PY{p}{[}\PY{l+m+mi}{8}\PY{p}{]}
              \PY{k}{print} \PY{n}{energy}\PY{p}{,}\PY{n}{gmax}\PY{p}{,}\PY{n}{time}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
-6095.12544083 0.03686 1391.5
-6095.25762870 0.00732 10468.0
-6095.26325979 0.00233 11963.5
-6095.26428124 0.00109 13331.9
-6095.26463203 0.00057 14710.8
-6095.26477615 0.00043 20211.1
-6095.26482624 0.00015 21726.1
-6095.26483584 0.00021 24890.5
-6095.26484405 0.00005 26448.7
-6095.26484599 0.00003 27258.1
-6095.26484676 0.00003 28155.3
-6095.26484693 0.00002 28981.7
-6095.26484693 0.00002 28981.7

    \end{Verbatim}

    This is fine for printing things out, but if we want to do something
with the data, either make a calculation with it or pass it into a
plotting, we need to convert the strings into regular floating point
numbers. We can use the \textbf{float()} command for this. We also need
to save it in some form. I'll do this as follows:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}143}]:} \PY{n}{data} \PY{o}{=} \PY{p}{[}\PY{p}{]}
          \PY{k}{for} \PY{n}{line} \PY{o+ow}{in} \PY{n}{lines}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{:}\PY{p}{]}\PY{p}{:}
              \PY{c+c1}{\PYZsh{} do something with each line}
              \PY{n}{words} \PY{o}{=} \PY{n}{line}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{p}{)}
              \PY{n}{energy} \PY{o}{=} \PY{n+nb}{float}\PY{p}{(}\PY{n}{words}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}
              \PY{n}{gmax} \PY{o}{=} \PY{n+nb}{float}\PY{p}{(}\PY{n}{words}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{]}\PY{p}{)}
              \PY{n}{time} \PY{o}{=} \PY{n+nb}{float}\PY{p}{(}\PY{n}{words}\PY{p}{[}\PY{l+m+mi}{8}\PY{p}{]}\PY{p}{)}
              \PY{n}{data}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{p}{(}\PY{n}{energy}\PY{p}{,}\PY{n}{gmax}\PY{p}{,}\PY{n}{time}\PY{p}{)}\PY{p}{)}
          \PY{n}{data} \PY{o}{=} \PY{n}{array}\PY{p}{(}\PY{n}{data}\PY{p}{)}
\end{Verbatim}


    We now have our data in a numpy array, so we can choose columns to
print:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}144}]:} \PY{n}{plot}\PY{p}{(}\PY{n}{data}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
          \PY{n}{xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{step}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
          \PY{n}{ylabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Energy (hartrees)}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
          \PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Convergence of NWChem geometry optimization for Si cluster}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}144}]:} <matplotlib.text.Text at 0x110335650>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_265_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    I would write the code a little more succinctly if I were doing this for
myself, but this is essentially a snippet I use repeatedly.

Suppose our data was in CSV (comma separated values) format, a format
that originally came from Microsoft Excel, and is increasingly used as a
data interchange format in big data applications. How would we parse
that?

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}145}]:} \PY{n}{csv} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{l+s+se}{\PYZbs{}}
          \PY{l+s+s2}{\PYZhy{}6095.12544083, 0.03686, 1391.5}
          \PY{l+s+s2}{\PYZhy{}6095.25762870, 0.00732, 10468.0}
          \PY{l+s+s2}{\PYZhy{}6095.26325979, 0.00233, 11963.5}
          \PY{l+s+s2}{\PYZhy{}6095.26428124, 0.00109, 13331.9}
          \PY{l+s+s2}{\PYZhy{}6095.26463203, 0.00057, 14710.8}
          \PY{l+s+s2}{\PYZhy{}6095.26477615, 0.00043, 20211.1}
          \PY{l+s+s2}{\PYZhy{}6095.26482624, 0.00015, 21726.1}
          \PY{l+s+s2}{\PYZhy{}6095.26483584, 0.00021, 24890.5}
          \PY{l+s+s2}{\PYZhy{}6095.26484405, 0.00005, 26448.7}
          \PY{l+s+s2}{\PYZhy{}6095.26484599, 0.00003, 27258.1}
          \PY{l+s+s2}{\PYZhy{}6095.26484676, 0.00003, 28155.3}
          \PY{l+s+s2}{\PYZhy{}6095.26484693, 0.00002, 28981.7}
          \PY{l+s+s2}{\PYZhy{}6095.26484693, 0.00002, 28981.7}\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
\end{Verbatim}


    We can do much the same as before:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}146}]:} \PY{n}{data} \PY{o}{=} \PY{p}{[}\PY{p}{]}
          \PY{k}{for} \PY{n}{line} \PY{o+ow}{in} \PY{n}{csv}\PY{o}{.}\PY{n}{splitlines}\PY{p}{(}\PY{p}{)}\PY{p}{:}
              \PY{n}{words} \PY{o}{=} \PY{n}{line}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{,}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
              \PY{n}{data}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n+nb}{map}\PY{p}{(}\PY{n+nb}{float}\PY{p}{,}\PY{n}{words}\PY{p}{)}\PY{p}{)}
          \PY{n}{data} \PY{o}{=} \PY{n}{array}\PY{p}{(}\PY{n}{data}\PY{p}{)}
\end{Verbatim}


    There are two significant changes over what we did earlier. First, I'm
passing the comma character ',' into the split function, so that it
breaks to a new word every time it sees a comma. Next, to simplify
things a big, I'm using the \textbf{map()} command to repeatedly apply a
single function (\textbf{float()}) to a list, and to return the output
as a list.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}147}]:} \PY{n}{help}\PY{p}{(}\PY{n+nb}{map}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Help on built-in function map in module \_\_builtin\_\_:

map({\ldots})
    map(function, sequence[, sequence, {\ldots}]) -> list
    
    Return a list of the results of applying the function to the items of
    the argument sequence(s).  If more than one sequence is given, the
    function is called with an argument list consisting of the corresponding
    item of each sequence, substituting None for missing values when not all
    sequences have the same length.  If the function is None, return a list of
    the items of the sequence (or a list of tuples if more than one sequence).


    \end{Verbatim}

    Despite the differences, the resulting plot should be the same:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}148}]:} \PY{n}{plot}\PY{p}{(}\PY{n}{data}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
          \PY{n}{xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{step}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
          \PY{n}{ylabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Energy (hartrees)}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
          \PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Convergence of NWChem geometry optimization for Si cluster}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}148}]:} <matplotlib.text.Text at 0x10fcc7d50>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_273_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    Hartrees (what most quantum chemistry programs use by default) are
really stupid units. We really want this in kcal/mol or eV or something
we use. So let's quickly replot this in terms of eV above the minimum
energy, which will give us a much more useful plot:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}149}]:} \PY{n}{energies} \PY{o}{=} \PY{n}{data}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{]}
          \PY{n}{minE} \PY{o}{=} \PY{n+nb}{min}\PY{p}{(}\PY{n}{energies}\PY{p}{)}
          \PY{n}{energies\PYZus{}eV} \PY{o}{=} \PY{l+m+mf}{27.211}\PY{o}{*}\PY{p}{(}\PY{n}{energies}\PY{o}{\PYZhy{}}\PY{n}{minE}\PY{p}{)}
          \PY{n}{plot}\PY{p}{(}\PY{n}{energies\PYZus{}eV}\PY{p}{)}
          \PY{n}{xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{step}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
          \PY{n}{ylabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Energy (eV)}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
          \PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Convergence of NWChem geometry optimization for Si cluster}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}149}]:} <matplotlib.text.Text at 0x110222350>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_275_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    This gives us the output in a form that we can think about: 4 eV is a
fairly substantial energy change (chemical bonds are roughly this
magnitude of energy), and most of the energy decrease was obtained in
the first geometry iteration.

    We mentioned earlier that we don't have to rely on \textbf{grep} to pull
out the relevant lines for us. The \textbf{string} module has a lot of
useful functions we can use for this. Among them is the
\textbf{startswith} function. For example:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}150}]:} \PY{n}{lines} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{l+s+se}{\PYZbs{}}
          \PY{l+s+s2}{                 \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
          \PY{l+s+s2}{                 |  WALL  |       0.45   |     443.61   |}
          \PY{l+s+s2}{                 \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
          
          \PY{l+s+s2}{@ Step       Energy      Delta E   Gmax     Grms     Xrms     Xmax   Walltime}
          \PY{l+s+s2}{@ \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{} \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{} \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{} \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{} \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{} \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{} \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{} \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
          \PY{l+s+s2}{@    0   \PYZhy{}6095.12544083  0.0D+00  0.03686  0.00936  0.00000  0.00000   1391.5}
          \PY{l+s+s2}{                                                       ok       ok}
          
          
          
          \PY{l+s+s2}{                                Z\PYZhy{}matrix (autoz)}
          \PY{l+s+s2}{                                \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
          \PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{o}{.}\PY{n}{splitlines}\PY{p}{(}\PY{p}{)}
          
          \PY{k}{for} \PY{n}{line} \PY{o+ow}{in} \PY{n}{lines}\PY{p}{:}
              \PY{k}{if} \PY{n}{line}\PY{o}{.}\PY{n}{startswith}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{@}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{:}
                  \PY{k}{print} \PY{n}{line}
                  
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
@ Step       Energy      Delta E   Gmax     Grms     Xrms     Xmax   Walltime
@ ---- ---------------- -------- -------- -------- -------- -------- --------
@    0   -6095.12544083  0.0D+00  0.03686  0.00936  0.00000  0.00000   1391.5

    \end{Verbatim}

    and we've successfully grabbed all of the lines that begin with the @
symbol.

    The real value in a language like Python is that it makes it easy to
take additional steps to analyze data in this fashion, which means you
are thinking more about your data, and are more likely to see important
patterns.

    \subsection{More Sophisticated String Formatting and
Processing}\label{more-sophisticated-string-formatting-and-processing}

Strings are a big deal in most modern languages, and hopefully the
previous sections helped underscore how versatile Python's string
processing techniques are. We will continue this topic in this chapter.

We can print out lines in Python using the print command.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}151}]:} \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{I have 3 errands to run}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
I have 3 errands to run

    \end{Verbatim}

    In IPython we don't even need the print command, since it will display
the last expression not assigned to a variable.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}152}]:} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{I have 3 errands to run}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}152}]:} 'I have 3 errands to run'
\end{Verbatim}
            
    \textbf{print} even converts some arguments to strings for us:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}153}]:} \PY{n}{a}\PY{p}{,}\PY{n}{b}\PY{p}{,}\PY{n}{c} \PY{o}{=} \PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}
          \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The variables are }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
The variables are  1 2 3

    \end{Verbatim}

    As versatile as this is, you typically need more freedom over the data
you print out. For example, what if we want to print a bunch of data to
exactly 4 decimal places? We can do this using formatted strings.

Formatted strings share a syntax with the C \textbf{printf} statement.
We make a string that has some funny \emph{format characters} in it, and
then pass a bunch of variables into the string that fill out those
characters in different ways.

For example,

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}154}]:} \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Pi as a decimal = }\PY{l+s+si}{\PYZpc{}d}\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{n}{pi}
          \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Pi as a float = }\PY{l+s+si}{\PYZpc{}f}\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{n}{pi}
          \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Pi with 4 decimal places = }\PY{l+s+si}{\PYZpc{}.4f}\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{n}{pi}
          \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Pi with overall fixed length of 10 spaces, with 6 decimal places = }\PY{l+s+si}{\PYZpc{}10.6f}\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{n}{pi}
          \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Pi as in exponential format = }\PY{l+s+si}{\PYZpc{}e}\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{n}{pi}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Pi as a decimal = 3
Pi as a float = 3.141593
Pi with 4 decimal places = 3.1416
Pi with overall fixed length of 10 spaces, with 6 decimal places =   3.141593
Pi as in exponential format = 3.141593e+00

    \end{Verbatim}

    We use a percent sign in two different ways here. First, the format
character itself starts with a percent sign. \%d or \%i are for
integers, \%f is for floats, \%e is for numbers in exponential formats.
All of the numbers can take number immediately after the percent that
specifies the total spaces used to print the number. Formats with a
decimal can take an additional number after a dot . to specify the
number of decimal places to print.

The other use of the percent sign is after the string, to pipe a set of
variables in. You can pass in multiple variables (if your formatting
string supports it) by putting a tuple after the percent. Thus,

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}155}]:} \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The variables specified earlier are }\PY{l+s+si}{\PYZpc{}d}\PY{l+s+s2}{, }\PY{l+s+si}{\PYZpc{}d}\PY{l+s+s2}{, and }\PY{l+s+si}{\PYZpc{}d}\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{p}{(}\PY{n}{a}\PY{p}{,}\PY{n}{b}\PY{p}{,}\PY{n}{c}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
The variables specified earlier are 1, 2, and 3

    \end{Verbatim}

    This is a simple formatting structure that will satisfy most of your
string formatting needs. More information on different format symbols is
available in the
\href{http://docs.python.org/release/2.5.2/lib/typesseq-strings.html}{string
formatting part of the standard docs}.

It's worth noting that more complicated string formatting methods are in
development, but I prefer this system due to its simplicity and its
similarity to C formatting strings.

Recall we discussed multiline strings. We can put format characters in
these as well, and fill them with the percent sign as before.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}156}]:} \PY{n}{form\PYZus{}letter} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{l+s+se}{\PYZbs{}}
          
          \PY{l+s+s2}{          }\PY{l+s+si}{\PYZpc{}s}
          
          \PY{l+s+s2}{Dear }\PY{l+s+si}{\PYZpc{}s}\PY{l+s+s2}{,}
          
          \PY{l+s+s2}{We regret to inform you that your product did not}
          \PY{l+s+s2}{ship today due to }\PY{l+s+si}{\PYZpc{}s}\PY{l+s+s2}{.}
          
          \PY{l+s+s2}{We hope to remedy this as soon as possible.}
          
          \PY{l+s+s2}{          From,}
          \PY{l+s+s2}{          Your Supplier}
          \PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
          
          \PY{k}{print} \PY{n}{form\PYZus{}letter} \PY{o}{\PYZpc{}} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{July 1, 2013}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Valued Customer Bob}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{alien attack}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]

          July 1, 2013

Dear Valued Customer Bob,

We regret to inform you that your product did not
ship today due to alien attack.

We hope to remedy this as soon as possible.

          From,
          Your Supplier


    \end{Verbatim}

    The problem with a long block of text like this is that it's often hard
to keep track of what all of the variables are supposed to stand for.
There's an alternate format where you can pass a dictionary into the
formatted string, and give a little bit more information to the
formatted string itself. This method looks like:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}157}]:} \PY{n}{form\PYZus{}letter} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{l+s+se}{\PYZbs{}}
          
          \PY{l+s+s2}{          }\PY{l+s+si}{\PYZpc{}(date)s}
          
          \PY{l+s+s2}{Dear }\PY{l+s+si}{\PYZpc{}(customer)s}\PY{l+s+s2}{,}
          
          \PY{l+s+s2}{We regret to inform you that your product did not}
          \PY{l+s+s2}{ship today due to }\PY{l+s+si}{\PYZpc{}(lame\PYZus{}excuse)s}\PY{l+s+s2}{.}
          
          \PY{l+s+s2}{We hope to remedy this as soon as possible.}
          
          \PY{l+s+s2}{          From,}
          \PY{l+s+s2}{          Your Supplier}
          \PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
          
          \PY{k}{print} \PY{n}{form\PYZus{}letter} \PY{o}{\PYZpc{}} \PY{p}{\PYZob{}}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{date}\PY{l+s+s2}{\PYZdq{}} \PY{p}{:} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{July 1, 2013}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{customer}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Valued Customer Bob}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{lame\PYZus{}excuse}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{alien attack}\PY{l+s+s2}{\PYZdq{}}\PY{p}{\PYZcb{}}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]

          July 1, 2013

Dear Valued Customer Bob,

We regret to inform you that your product did not
ship today due to alien attack.

We hope to remedy this as soon as possible.

          From,
          Your Supplier


    \end{Verbatim}

    By providing a little bit more information, you're less likely to make
mistakes, like referring to your customer as "alien attack".

As a scientist, you're less likely to be sending bulk mailings to a
bunch of customers. But these are great methods for generating and
submitting lots of similar runs, say scanning a bunch of different
structures to find the optimal configuration for something.

For example, you can use the following template for NWChem input files:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}158}]:} \PY{n}{nwchem\PYZus{}format} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
          \PY{l+s+s2}{start }\PY{l+s+si}{\PYZpc{}(jobname)s}
          
          \PY{l+s+s2}{title }\PY{l+s+s2}{\PYZdq{}}\PY{l+s+si}{\PYZpc{}(thetitle)s}\PY{l+s+s2}{\PYZdq{}}
          \PY{l+s+s2}{charge }\PY{l+s+si}{\PYZpc{}(charge)d}
          
          \PY{l+s+s2}{geometry units angstroms print xyz autosym}
          \PY{l+s+si}{\PYZpc{}(geometry)s}
          \PY{l+s+s2}{end}
          
          \PY{l+s+s2}{basis}
          \PY{l+s+s2}{  * library 6\PYZhy{}31G**}
          \PY{l+s+s2}{end}
          
          \PY{l+s+s2}{dft}
          \PY{l+s+s2}{  xc }\PY{l+s+si}{\PYZpc{}(dft\PYZus{}functional)s}
          \PY{l+s+s2}{  mult }\PY{l+s+si}{\PYZpc{}(multiplicity)d}
          \PY{l+s+s2}{end}
          
          \PY{l+s+s2}{task dft }\PY{l+s+si}{\PYZpc{}(jobtype)s}
          \PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
\end{Verbatim}


    If you want to submit a sequence of runs to a computer somewhere, it's
pretty easy to put together a little script, maybe even with some more
string formatting in it:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}159}]:} \PY{n}{oxygen\PYZus{}xy\PYZus{}coords} \PY{o}{=} \PY{p}{[}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mf}{0.1}\PY{p}{)}\PY{p}{,}\PY{p}{(}\PY{l+m+mf}{0.1}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,}\PY{p}{(}\PY{l+m+mf}{0.1}\PY{p}{,}\PY{l+m+mf}{0.1}\PY{p}{)}\PY{p}{]}
          \PY{n}{charge} \PY{o}{=} \PY{l+m+mi}{0}
          \PY{n}{multiplicity} \PY{o}{=} \PY{l+m+mi}{1}
          \PY{n}{dft\PYZus{}functional} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{b3lyp}\PY{l+s+s2}{\PYZdq{}}
          \PY{n}{jobtype} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{optimize}\PY{l+s+s2}{\PYZdq{}}
          
          \PY{n}{geometry\PYZus{}template} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{l+s+se}{\PYZbs{}}
          \PY{l+s+s2}{  O    }\PY{l+s+si}{\PYZpc{}f}\PY{l+s+s2}{     }\PY{l+s+si}{\PYZpc{}f}\PY{l+s+s2}{      0.0}
          \PY{l+s+s2}{  H    0.0    1.0     0.0}
          \PY{l+s+s2}{  H    1.0    0.0     0.0}\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
          
          \PY{k}{for} \PY{n}{i}\PY{p}{,}\PY{n}{xy} \PY{o+ow}{in} \PY{n+nb}{enumerate}\PY{p}{(}\PY{n}{oxygen\PYZus{}xy\PYZus{}coords}\PY{p}{)}\PY{p}{:}
              \PY{n}{thetitle} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Water run \PYZsh{}}\PY{l+s+si}{\PYZpc{}d}\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{n}{i}
              \PY{n}{jobname} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{h2o\PYZhy{}}\PY{l+s+si}{\PYZpc{}d}\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{n}{i}
              \PY{n}{geometry} \PY{o}{=} \PY{n}{geometry\PYZus{}template} \PY{o}{\PYZpc{}} \PY{n}{xy}
              \PY{k}{print} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}\PY{l+s+s2}{\PYZdq{}}
              \PY{k}{print} \PY{n}{nwchem\PYZus{}format} \PY{o}{\PYZpc{}} \PY{n+nb}{dict}\PY{p}{(}\PY{n}{thetitle}\PY{o}{=}\PY{n}{thetitle}\PY{p}{,}\PY{n}{charge}\PY{o}{=}\PY{n}{charge}\PY{p}{,}\PY{n}{jobname}\PY{o}{=}\PY{n}{jobname}\PY{p}{,}\PY{n}{jobtype}\PY{o}{=}\PY{n}{jobtype}\PY{p}{,}
                                         \PY{n}{geometry}\PY{o}{=}\PY{n}{geometry}\PY{p}{,}\PY{n}{dft\PYZus{}functional}\PY{o}{=}\PY{n}{dft\PYZus{}functional}\PY{p}{,}\PY{n}{multiplicity}\PY{o}{=}\PY{n}{multiplicity}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
---------

start h2o-0

title "Water run \#0"
charge 0

geometry units angstroms print xyz autosym
  O    0.000000     0.000000      0.0
  H    0.0    1.0     0.0
  H    1.0    0.0     0.0
end

basis
  * library 6-31G**
end

dft
  xc b3lyp
  mult 1
end

task dft optimize

---------

start h2o-1

title "Water run \#1"
charge 0

geometry units angstroms print xyz autosym
  O    0.000000     0.100000      0.0
  H    0.0    1.0     0.0
  H    1.0    0.0     0.0
end

basis
  * library 6-31G**
end

dft
  xc b3lyp
  mult 1
end

task dft optimize

---------

start h2o-2

title "Water run \#2"
charge 0

geometry units angstroms print xyz autosym
  O    0.100000     0.000000      0.0
  H    0.0    1.0     0.0
  H    1.0    0.0     0.0
end

basis
  * library 6-31G**
end

dft
  xc b3lyp
  mult 1
end

task dft optimize

---------

start h2o-3

title "Water run \#3"
charge 0

geometry units angstroms print xyz autosym
  O    0.100000     0.100000      0.0
  H    0.0    1.0     0.0
  H    1.0    0.0     0.0
end

basis
  * library 6-31G**
end

dft
  xc b3lyp
  mult 1
end

task dft optimize


    \end{Verbatim}

    This is a very bad geometry for a water molecule, and it would be silly
to run so many geometry optimizations of structures that are guaranteed
to converge to the same single geometry, but you get the idea of how you
can run vast numbers of simulations with a technique like this.

We used the \textbf{enumerate} function to loop over both the indices
and the items of a sequence, which is valuable when you want a clean way
of getting both. \textbf{enumerate} is roughly equivalent to:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}160}]:} \PY{k}{def} \PY{n+nf}{my\PYZus{}enumerate}\PY{p}{(}\PY{n}{seq}\PY{p}{)}\PY{p}{:}
              \PY{n}{l} \PY{o}{=} \PY{p}{[}\PY{p}{]}
              \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{seq}\PY{p}{)}\PY{p}{)}\PY{p}{:}
                  \PY{n}{l}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{seq}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)}\PY{p}{)}
              \PY{k}{return} \PY{n}{l}
          \PY{n}{my\PYZus{}enumerate}\PY{p}{(}\PY{n}{oxygen\PYZus{}xy\PYZus{}coords}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}160}]:} [(0, (0, 0)), (1, (0, 0.1)), (2, (0.1, 0)), (3, (0.1, 0.1))]
\end{Verbatim}
            
    Although enumerate uses \textbf{generators} (see below) so that it
doesn't have to create a big list, which makes it faster for really long
sequenes.

    \subsection{Optional arguments}\label{optional-arguments}

You will recall that the \textbf{linspace} function can take either two
arguments (for the starting and ending points):

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}161}]:} \PY{n}{linspace}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}161}]:} array([ 0.        ,  0.02040816,  0.04081633,  0.06122449,  0.08163265,
                  0.10204082,  0.12244898,  0.14285714,  0.16326531,  0.18367347,
                  0.20408163,  0.2244898 ,  0.24489796,  0.26530612,  0.28571429,
                  0.30612245,  0.32653061,  0.34693878,  0.36734694,  0.3877551 ,
                  0.40816327,  0.42857143,  0.44897959,  0.46938776,  0.48979592,
                  0.51020408,  0.53061224,  0.55102041,  0.57142857,  0.59183673,
                  0.6122449 ,  0.63265306,  0.65306122,  0.67346939,  0.69387755,
                  0.71428571,  0.73469388,  0.75510204,  0.7755102 ,  0.79591837,
                  0.81632653,  0.83673469,  0.85714286,  0.87755102,  0.89795918,
                  0.91836735,  0.93877551,  0.95918367,  0.97959184,  1.        ])
\end{Verbatim}
            
    or it can take three arguments, for the starting point, the ending
point, and the number of points:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}162}]:} \PY{n}{linspace}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}162}]:} array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])
\end{Verbatim}
            
    You can also pass in keywords to exclude the endpoint:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}163}]:} \PY{n}{linspace}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{,}\PY{n}{endpoint}\PY{o}{=}\PY{n+nb+bp}{False}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}163}]:} array([ 0. ,  0.2,  0.4,  0.6,  0.8])
\end{Verbatim}
            
    Right now, we only know how to specify functions that have a fixed
number of arguments. We'll learn how to do the more general cases here.

If we're defining a simple version of linspace, we would start with:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}164}]:} \PY{k}{def} \PY{n+nf}{my\PYZus{}linspace}\PY{p}{(}\PY{n}{start}\PY{p}{,}\PY{n}{end}\PY{p}{)}\PY{p}{:}
              \PY{n}{npoints} \PY{o}{=} \PY{l+m+mi}{50}
              \PY{n}{v} \PY{o}{=} \PY{p}{[}\PY{p}{]}
              \PY{n}{d} \PY{o}{=} \PY{p}{(}\PY{n}{end}\PY{o}{\PYZhy{}}\PY{n}{start}\PY{p}{)}\PY{o}{/}\PY{n+nb}{float}\PY{p}{(}\PY{n}{npoints}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}
              \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{npoints}\PY{p}{)}\PY{p}{:}
                  \PY{n}{v}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{start} \PY{o}{+} \PY{n}{i}\PY{o}{*}\PY{n}{d}\PY{p}{)}
              \PY{k}{return} \PY{n}{v}
          \PY{n}{my\PYZus{}linspace}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}164}]:} [0.0,
           0.02040816326530612,
           0.04081632653061224,
           0.061224489795918366,
           0.08163265306122448,
           0.1020408163265306,
           0.12244897959183673,
           0.14285714285714285,
           0.16326530612244897,
           0.18367346938775508,
           0.2040816326530612,
           0.22448979591836732,
           0.24489795918367346,
           0.26530612244897955,
           0.2857142857142857,
           0.3061224489795918,
           0.32653061224489793,
           0.3469387755102041,
           0.36734693877551017,
           0.3877551020408163,
           0.4081632653061224,
           0.42857142857142855,
           0.44897959183673464,
           0.4693877551020408,
           0.4897959183673469,
           0.5102040816326531,
           0.5306122448979591,
           0.5510204081632653,
           0.5714285714285714,
           0.5918367346938775,
           0.6122448979591836,
           0.6326530612244897,
           0.6530612244897959,
           0.673469387755102,
           0.6938775510204082,
           0.7142857142857142,
           0.7346938775510203,
           0.7551020408163265,
           0.7755102040816326,
           0.7959183673469387,
           0.8163265306122448,
           0.836734693877551,
           0.8571428571428571,
           0.8775510204081632,
           0.8979591836734693,
           0.9183673469387754,
           0.9387755102040816,
           0.9591836734693877,
           0.9795918367346939,
           0.9999999999999999]
\end{Verbatim}
            
    We can add an optional argument by specifying a default value in the
argument list:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}165}]:} \PY{k}{def} \PY{n+nf}{my\PYZus{}linspace}\PY{p}{(}\PY{n}{start}\PY{p}{,}\PY{n}{end}\PY{p}{,}\PY{n}{npoints} \PY{o}{=} \PY{l+m+mi}{50}\PY{p}{)}\PY{p}{:}
              \PY{n}{v} \PY{o}{=} \PY{p}{[}\PY{p}{]}
              \PY{n}{d} \PY{o}{=} \PY{p}{(}\PY{n}{end}\PY{o}{\PYZhy{}}\PY{n}{start}\PY{p}{)}\PY{o}{/}\PY{n+nb}{float}\PY{p}{(}\PY{n}{npoints}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}
              \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{npoints}\PY{p}{)}\PY{p}{:}
                  \PY{n}{v}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{start} \PY{o}{+} \PY{n}{i}\PY{o}{*}\PY{n}{d}\PY{p}{)}
              \PY{k}{return} \PY{n}{v}
\end{Verbatim}


    This gives exactly the same result if we don't specify anything:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}166}]:} \PY{n}{my\PYZus{}linspace}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}166}]:} [0.0,
           0.02040816326530612,
           0.04081632653061224,
           0.061224489795918366,
           0.08163265306122448,
           0.1020408163265306,
           0.12244897959183673,
           0.14285714285714285,
           0.16326530612244897,
           0.18367346938775508,
           0.2040816326530612,
           0.22448979591836732,
           0.24489795918367346,
           0.26530612244897955,
           0.2857142857142857,
           0.3061224489795918,
           0.32653061224489793,
           0.3469387755102041,
           0.36734693877551017,
           0.3877551020408163,
           0.4081632653061224,
           0.42857142857142855,
           0.44897959183673464,
           0.4693877551020408,
           0.4897959183673469,
           0.5102040816326531,
           0.5306122448979591,
           0.5510204081632653,
           0.5714285714285714,
           0.5918367346938775,
           0.6122448979591836,
           0.6326530612244897,
           0.6530612244897959,
           0.673469387755102,
           0.6938775510204082,
           0.7142857142857142,
           0.7346938775510203,
           0.7551020408163265,
           0.7755102040816326,
           0.7959183673469387,
           0.8163265306122448,
           0.836734693877551,
           0.8571428571428571,
           0.8775510204081632,
           0.8979591836734693,
           0.9183673469387754,
           0.9387755102040816,
           0.9591836734693877,
           0.9795918367346939,
           0.9999999999999999]
\end{Verbatim}
            
    But also let's us override the default value with a third argument:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}167}]:} \PY{n}{my\PYZus{}linspace}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}167}]:} [0.0, 0.25, 0.5, 0.75, 1.0]
\end{Verbatim}
            
    We can add arbitrary keyword arguments to the function definition by
putting a keyword argument **kwargs handle in:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}168}]:} \PY{k}{def} \PY{n+nf}{my\PYZus{}linspace}\PY{p}{(}\PY{n}{start}\PY{p}{,}\PY{n}{end}\PY{p}{,}\PY{n}{npoints}\PY{o}{=}\PY{l+m+mi}{50}\PY{p}{,}\PY{o}{*}\PY{o}{*}\PY{n}{kwargs}\PY{p}{)}\PY{p}{:}
              \PY{n}{endpoint} \PY{o}{=} \PY{n}{kwargs}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{endpoint}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{n+nb+bp}{True}\PY{p}{)}
              \PY{n}{v} \PY{o}{=} \PY{p}{[}\PY{p}{]}
              \PY{k}{if} \PY{n}{endpoint}\PY{p}{:}
                  \PY{n}{d} \PY{o}{=} \PY{p}{(}\PY{n}{end}\PY{o}{\PYZhy{}}\PY{n}{start}\PY{p}{)}\PY{o}{/}\PY{n+nb}{float}\PY{p}{(}\PY{n}{npoints}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}
              \PY{k}{else}\PY{p}{:}
                  \PY{n}{d} \PY{o}{=} \PY{p}{(}\PY{n}{end}\PY{o}{\PYZhy{}}\PY{n}{start}\PY{p}{)}\PY{o}{/}\PY{n+nb}{float}\PY{p}{(}\PY{n}{npoints}\PY{p}{)}
              \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{npoints}\PY{p}{)}\PY{p}{:}
                  \PY{n}{v}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{start} \PY{o}{+} \PY{n}{i}\PY{o}{*}\PY{n}{d}\PY{p}{)}
              \PY{k}{return} \PY{n}{v}
          \PY{n}{my\PYZus{}linspace}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{,}\PY{n}{endpoint}\PY{o}{=}\PY{n+nb+bp}{False}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}168}]:} [0.0, 0.2, 0.4, 0.6000000000000001, 0.8]
\end{Verbatim}
            
    What the keyword argument construction does is to take any additional
keyword arguments (i.e. arguments specified by name, like
"endpoint=False"), and stick them into a dictionary called "kwargs" (you
can call it anything you like, but it has to be preceded by two stars).
You can then grab items out of the dictionary using the \textbf{get}
command, which also lets you specify a default value. I realize it takes
a little getting used to, but it is a common construction in Python
code, and you should be able to recognize it.

There's an analogous *args that dumps any additional arguments into a
list called "args". Think about the \textbf{range} function: it can take
one (the endpoint), two (starting and ending points), or three
(starting, ending, and step) arguments. How would we define this?

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}169}]:} \PY{k}{def} \PY{n+nf}{my\PYZus{}range}\PY{p}{(}\PY{o}{*}\PY{n}{args}\PY{p}{)}\PY{p}{:}
              \PY{n}{start} \PY{o}{=} \PY{l+m+mi}{0}
              \PY{n}{step} \PY{o}{=} \PY{l+m+mi}{1}
              \PY{k}{if} \PY{n+nb}{len}\PY{p}{(}\PY{n}{args}\PY{p}{)} \PY{o}{==} \PY{l+m+mi}{1}\PY{p}{:}
                  \PY{n}{end} \PY{o}{=} \PY{n}{args}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
              \PY{k}{elif} \PY{n+nb}{len}\PY{p}{(}\PY{n}{args}\PY{p}{)} \PY{o}{==} \PY{l+m+mi}{2}\PY{p}{:}
                  \PY{n}{start}\PY{p}{,}\PY{n}{end} \PY{o}{=} \PY{n}{args}
              \PY{k}{elif} \PY{n+nb}{len}\PY{p}{(}\PY{n}{args}\PY{p}{)} \PY{o}{==} \PY{l+m+mi}{3}\PY{p}{:}
                  \PY{n}{start}\PY{p}{,}\PY{n}{end}\PY{p}{,}\PY{n}{step} \PY{o}{=} \PY{n}{args}
              \PY{k}{else}\PY{p}{:}
                  \PY{k}{raise} \PY{n+ne}{Exception}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Unable to parse arguments}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
              \PY{n}{v} \PY{o}{=} \PY{p}{[}\PY{p}{]}
              \PY{n}{value} \PY{o}{=} \PY{n}{start}
              \PY{k}{while} \PY{n+nb+bp}{True}\PY{p}{:}
                  \PY{n}{v}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{value}\PY{p}{)}
                  \PY{n}{value} \PY{o}{+}\PY{o}{=} \PY{n}{step}
                  \PY{k}{if} \PY{n}{value} \PY{o}{\PYZgt{}} \PY{n}{end}\PY{p}{:} \PY{k}{break}
              \PY{k}{return} \PY{n}{v}
\end{Verbatim}


    Note that we have defined a few new things you haven't seen before: a
\textbf{break} statement, that allows us to exit a for loop if some
conditions are met, and an exception statement, that causes the
interpreter to exit with an error message. For example:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}170}]:} \PY{n}{my\PYZus{}range}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]

        ---------------------------------------------------------------------------
    Exception                                 Traceback (most recent call last)

        <ipython-input-170-0e8004dab150> in <module>()
    ----> 1 my\_range()
    

        <ipython-input-169-c34e09da2551> in my\_range(*args)
          9         start,end,step = args
         10     else:
    ---> 11         raise Exception("Unable to parse arguments")
         12     v = []
         13     value = start


        Exception: Unable to parse arguments

    \end{Verbatim}

    \subsection{List Comprehensions and
Generators}\label{list-comprehensions-and-generators}

List comprehensions are a streamlined way to make lists. They look
something like a list definition, with some logic thrown in. For
example:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{n}{evens1} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{i} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{]}
        \PY{k}{print} \PY{n}{evens1}
\end{Verbatim}


    You can also put some boolean testing into the construct:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{n}{odds} \PY{o}{=} \PY{p}{[}\PY{n}{i} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{)} \PY{k}{if} \PY{n}{i}\PY{o}{\PYZpc{}}\PY{k}{2}==1]
        \PY{n}{odds}
\end{Verbatim}


    Here i\%2 is the remainder when i is divided by 2, so that i\%2==1 is
true if the number is odd. Even though this is a relative new addition
to the language, it is now fairly common since it's so convenient.

    \textbf{iterators} are a way of making virtual sequence objects.
Consider if we had the nested loop structure:

\begin{verbatim}
for i in range(1000000):
    for j in range(1000000):
\end{verbatim}

Inside the main loop, we make a list of 1,000,000 integers, just to loop
over them one at a time. We don't need any of the additional things that
a lists gives us, like slicing or random access, we just need to go
through the numbers one at a time. And we're making 1,000,000 of them.

\textbf{iterators} are a way around this. For example, the
\textbf{xrange} function is the iterator version of range. This simply
makes a counter that is looped through in sequence, so that the
analogous loop structure would look like:

\begin{verbatim}
for i in xrange(1000000):
    for j in xrange(1000000):
\end{verbatim}

Even though we've only added two characters, we've dramatically sped up
the code, because we're not making 1,000,000 big lists.

We can define our own iterators using the \textbf{yield} statement:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}171}]:} \PY{k}{def} \PY{n+nf}{evens\PYZus{}below}\PY{p}{(}\PY{n}{n}\PY{p}{)}\PY{p}{:}
              \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{xrange}\PY{p}{(}\PY{n}{n}\PY{p}{)}\PY{p}{:}
                  \PY{k}{if} \PY{n}{i}\PY{o}{\PYZpc{}}\PY{k}{2} == 0:
                      \PY{k}{yield} \PY{n}{i}
              \PY{k}{return}
          
          \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n}{evens\PYZus{}below}\PY{p}{(}\PY{l+m+mi}{9}\PY{p}{)}\PY{p}{:}
              \PY{k}{print} \PY{n}{i}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
0
2
4
6
8

    \end{Verbatim}

    We can always turn an iterator into a list using the \textbf{list}
command:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}172}]:} \PY{n+nb}{list}\PY{p}{(}\PY{n}{evens\PYZus{}below}\PY{p}{(}\PY{l+m+mi}{9}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}172}]:} [0, 2, 4, 6, 8]
\end{Verbatim}
            
    There's a special syntax called a \textbf{generator expression} that
looks a lot like a list comprehension:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}173}]:} \PY{n}{evens\PYZus{}gen} \PY{o}{=} \PY{p}{(}\PY{n}{i} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{xrange}\PY{p}{(}\PY{l+m+mi}{9}\PY{p}{)} \PY{k}{if} \PY{n}{i}\PY{o}{\PYZpc{}}\PY{k}{2}==0)
          \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n}{evens\PYZus{}gen}\PY{p}{:}
              \PY{k}{print} \PY{n}{i}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
0
2
4
6
8

    \end{Verbatim}

    \subsection{Factory Functions}\label{factory-functions}

A factory function is a function that returns a function. They have the
fancy name \emph{lexical closure}, which makes you sound really
intelligent in front of your CS friends. But, despite the arcane names,
factory functions can play a very practical role.

Suppose you want the Gaussian function centered at 0.5, with height 99
and width 1.0. You could write a general function.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}174}]:} \PY{k}{def} \PY{n+nf}{gauss}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{A}\PY{p}{,}\PY{n}{a}\PY{p}{,}\PY{n}{x0}\PY{p}{)}\PY{p}{:}
              \PY{k}{return} \PY{n}{A}\PY{o}{*}\PY{n}{exp}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{n}{a}\PY{o}{*}\PY{p}{(}\PY{n}{x}\PY{o}{\PYZhy{}}\PY{n}{x0}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{p}{)}
\end{Verbatim}


    But what if you need a function with only one argument, like f(x) rather
than f(x,y,z,...)? You can do this with Factory Functions:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}175}]:} \PY{k}{def} \PY{n+nf}{gauss\PYZus{}maker}\PY{p}{(}\PY{n}{A}\PY{p}{,}\PY{n}{a}\PY{p}{,}\PY{n}{x0}\PY{p}{)}\PY{p}{:}
              \PY{k}{def} \PY{n+nf}{f}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
                  \PY{k}{return} \PY{n}{A}\PY{o}{*}\PY{n}{exp}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{n}{a}\PY{o}{*}\PY{p}{(}\PY{n}{x}\PY{o}{\PYZhy{}}\PY{n}{x0}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{p}{)}
              \PY{k}{return} \PY{n}{f}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}176}]:} \PY{n}{x} \PY{o}{=} \PY{n}{linspace}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
          \PY{n}{g} \PY{o}{=} \PY{n}{gauss\PYZus{}maker}\PY{p}{(}\PY{l+m+mf}{99.0}\PY{p}{,}\PY{l+m+mf}{1.0}\PY{p}{,}\PY{l+m+mf}{0.5}\PY{p}{)}
          \PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{g}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}176}]:} [<matplotlib.lines.Line2D at 0x110726990>]
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_337_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    Everything in Python is an object, including functions. This means that
functions can be returned by other functions. (They can also be passed
into other functions, which is also useful, but a topic for another
discussion.) In the \textbf{gauss\_maker} example, the \emph{g} function
that is output "remembers" the A, a, x0 values it was constructed with,
since they're all stored in the local memory space (this is what the
\emph{lexical closure} really refers to) of that function.

Factories are one of the more important of the
\href{http://en.wikipedia.org/wiki/Software_design_pattern}{Software
Design Patterns}, which are a set of guidelines to follow to make
high-quality, portable, readable, stable software. It's beyond the scope
of the current work to go more into either factories or design patterns,
but I thought I would mention them for people interested in software
design.

    \subsection{Serialization: Save it for
later}\label{serialization-save-it-for-later}

\emph{Serialization} refers to the process of outputting data (and
occasionally functions) to a database or a regular file, for the purpose
of using it later on. In the very early days of programming languages,
this was normally done in regular text files. Python is excellent at
text processing, and you probably already know enough to get started
with this.

When accessing large amounts of data became important, people developed
database software based around the Structured Query Language (SQL)
standard. I'm not going to cover SQL here, but, if you're interested, I
recommend using the
\href{http://docs.python.org/2/library/sqlite3.html}{sqlite3} module in
the Python standard library.

As data interchange became important, the eXtensible Markup Language
(XML) has emerged. XML makes data formats that are easy to write parsers
for, greatly simplifying the ambiguity that sometimes arises in the
process. Again, I'm not going to cover XML here, but if you're
interested in learning more, look into
\href{http://docs.python.org/2/library/xml.etree.elementtree.html}{Element
Trees}, now part of the Python standard library.

Python has a very general serialization format called \textbf{pickle}
that can turn any Python object, even a function or a class, into a
representation that can be written to a file and read in later. But,
again, I'm not going to talk about this, since I rarely use it myself.
Again,
\href{http://docs.python.org/2/library/pickle.html\#module-cPickle}{the
standard library documentation for pickle} is the place to go.

What I am going to talk about is a relatively recent format call
\href{http://json.org/}{JavaScript Object Notation} (JSON) that has
become very popular over the past few years.
\href{http://docs.python.org/2/library/json.html}{There's a module in
the standard library} for encoding and decoding JSON formats. The reason
I like JSON so much is that it looks almost like Python, so that, unlike
the other options, you can look at your data and edit it, use it in
another program, etc.

Here's a little example:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}177}]:} \PY{c+c1}{\PYZsh{} Data in a json format:}
          \PY{n}{json\PYZus{}data} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{l+s+se}{\PYZbs{}}
          \PY{l+s+s2}{\PYZob{}}
          \PY{l+s+s2}{    }\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{a}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{: [1,2,3],}
          \PY{l+s+s2}{    }\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{b}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{: [4,5,6],}
          \PY{l+s+s2}{    }\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{greeting}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ : }\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Hello}\PY{l+s+s2}{\PYZdq{}}
          \PY{l+s+s2}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
          \PY{k+kn}{import} \PY{n+nn}{json}
          \PY{n}{json}\PY{o}{.}\PY{n}{loads}\PY{p}{(}\PY{n}{json\PYZus{}data}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}177}]:} \{u'a': [1, 2, 3], u'b': [4, 5, 6], u'greeting': u'Hello'\}
\end{Verbatim}
            
    Ignore the little u's before the strings, these just mean the strings
are in UNICODE. Your data sits in something that looks like a Python
dictionary, and in a single line of code, you can load it into a Python
dictionary for use later.

In the same way, you can, with a single line of code, put a bunch of
variables into a dictionary, and then output to a file using json:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}178}]:} \PY{n}{json}\PY{o}{.}\PY{n}{dumps}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{a}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{b}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:}\PY{p}{[}\PY{l+m+mi}{9}\PY{p}{,}\PY{l+m+mi}{10}\PY{p}{,}\PY{l+m+mi}{11}\PY{p}{]}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{greeting}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Hola}\PY{l+s+s2}{\PYZdq{}}\PY{p}{\PYZcb{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}178}]:} '\{"a": [1, 2, 3], "b": [9, 10, 11], "greeting": "Hola"\}'
\end{Verbatim}
            
    \subsection{ Functional programming }\label{functional-programming}

Functional programming is a very broad subject. The idea is to have a
series of functions, each of which generates a new data structure from
an input, without changing the input structure at all. By not modifying
the input structure (something that is called not having \emph{side
effects}), many guarantees can be made about how independent the
processes are, which can help parallelization and guarantees of program
accuracy. There is a
\href{http://docs.python.org/2/howto/functional.html}{Python Functional
Programming HOWTO} in the standard docs that goes into more details on
functional programming. I just wanted to touch on a few of the most
important ideas here.

There is an \textbf{operator} module that has function versions of most
of the Python operators. For example:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}109}]:} \PY{k+kn}{from} \PY{n+nn}{operator} \PY{k+kn}{import} \PY{n}{add}\PY{p}{,} \PY{n}{mul}
          \PY{n}{add}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}109}]:} 3
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}110}]:} \PY{n}{mul}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}110}]:} 12
\end{Verbatim}
            
    These are useful building blocks for functional programming.

    The \textbf{lambda} operator allows us to build \emph{anonymous
functions}, which are simply functions that aren't defined by a normal
\textbf{def} statement with a name. For example, a function that doubles
the input is:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}111}]:} \PY{k}{def} \PY{n+nf}{doubler}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:} \PY{k}{return} \PY{l+m+mi}{2}\PY{o}{*}\PY{n}{x}
          \PY{n}{doubler}\PY{p}{(}\PY{l+m+mi}{17}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}111}]:} 34
\end{Verbatim}
            
    We could also write this as:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}112}]:} \PY{k}{lambda} \PY{n}{x}\PY{p}{:} \PY{l+m+mi}{2}\PY{o}{*}\PY{n}{x}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}112}]:} <function \_\_main\_\_.<lambda>>
\end{Verbatim}
            
    And assign it to a function separately:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}120}]:} \PY{n}{another\PYZus{}doubler} \PY{o}{=} \PY{k}{lambda} \PY{n}{x}\PY{p}{:} \PY{l+m+mi}{2}\PY{o}{*}\PY{n}{x}
          \PY{n}{another\PYZus{}doubler}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}120}]:} 20
\end{Verbatim}
            
    \textbf{lambda} is particularly convenient (as we'll see below) in
passing simple functions as arguments to other functions.

    \textbf{map} is a way to repeatedly apply a function to a list:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}123}]:} \PY{k}{print} \PY{n+nb}{map}\PY{p}{(}\PY{n+nb}{float}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{1 2 3 4 5}\PY{l+s+s1}{\PYZsq{}}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{p}{)}\PY{p}{)}
          
          
          \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}\PYZsh{}}
          \PY{n}{custom\PYZus{}sq}\PY{o}{=}\PY{k}{lambda} \PY{n}{x}\PY{p}{:} \PY{n}{x}\PY{o}{*}\PY{n}{x} 
          \PY{k}{print} \PY{n+nb}{map}\PY{p}{(}\PY{n}{custom\PYZus{}sq}\PY{p}{,} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
[1.0, 2.0, 3.0, 4.0, 5.0]
[0, 1, 4, 9, 16]

    \end{Verbatim}

    \textbf{reduce} is a way to repeatedly apply a function to the first two
items of the list. There already is a \textbf{sum} function in Python
that is a reduction:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}185}]:} \PY{n+nb}{sum}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}185}]:} 15
\end{Verbatim}
            
    We can use \textbf{reduce} to define an analogous \textbf{prod}
function:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}126}]:} \PY{k}{def} \PY{n+nf}{prod}\PY{p}{(}\PY{n}{l}\PY{p}{)}\PY{p}{:} \PY{k}{return} \PY{n+nb}{reduce}\PY{p}{(}\PY{n}{add}\PY{p}{,}\PY{n}{l}\PY{p}{)}
          \PY{n}{prod}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}126}]:} 15
\end{Verbatim}
            
    \subsection{Object Oriented
Programming}\label{object-oriented-programming}

    We've seen a lot of examples of \textbf{objects} in Python. We create a
string object with quote marks:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}127}]:} \PY{n}{mystring} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Hi there}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}


    and we have a bunch of methods we can use on the object:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}130}]:} \PY{n}{mystring}\PY{o}{.}\PY{n}{split}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}130}]:} ['Hi', 'there']
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}189}]:} \PY{n}{mystring}\PY{o}{.}\PY{n}{startswith}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Hi}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}189}]:} True
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}190}]:} \PY{n+nb}{len}\PY{p}{(}\PY{n}{mystring}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}190}]:} 8
\end{Verbatim}
            
    Object oriented programming simply gives you the tools to define objects
and methods for yourself. It's useful anytime you want to keep some data
(like the characters in the string) tightly coupled to the functions
that act on the data (length, split, startswith, etc.).

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}132}]:} \PY{k}{class} \PY{n+nc}{Person}\PY{p}{:}
            \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{name}\PY{p}{,} \PY{n}{age}\PY{p}{)}\PY{p}{:}
              \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{name} \PY{o}{=} \PY{n}{name}
              \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{age} \PY{o}{=} \PY{n}{age}
          
            \PY{k}{def} \PY{n+nf}{myfunc}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
              \PY{k}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Hello my name is }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{name}\PY{p}{)}
          
          \PY{n}{name}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{test}\PY{l+s+s1}{\PYZsq{}}
              
          \PY{n}{p1} \PY{o}{=} \PY{n}{Person}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{John}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{36}\PY{p}{)}
          \PY{n}{p1}\PY{o}{.}\PY{n}{myfunc}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Hello my name is John

    \end{Verbatim}

    \section{IV. Speeding Python: Timeit, Profiling, Cython, SWIG, and
PyPy}\label{iv.-speeding-python-timeit-profiling-cython-swig-and-pypy}

The first rule of speeding up your code is not to do it at all. As
Donald Knuth said:

\begin{quote}
"We should forget about small efficiencies, say about 97\% of the time:
premature optimization is the root of all evil."
\end{quote}

The second rule of speeding up your code is to only do it if you really
think you need to do it. Python has two tools to help with this process:
a timing program called \textbf{timeit}, and a very good code profiler.
We will discuss both of these tools in this section, as well as
techniques to use to speed up your code once you know it's too slow.

\subsection{Timeit}\label{timeit}

\textbf{timeit} helps determine which of two similar routines is faster.
Recall that some time ago we wrote a factorial routine, but also pointed
out that Python had its own routine built into the math module. Is there
any difference in the speed of the two? \textbf{timeit} helps us
determine this. For example, \textbf{timeit} tells how long each method
takes:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}22}]:} \PY{k+kn}{import} \PY{n+nn}{math}
         \PY{o}{\PYZpc{}}\PY{k}{timeit} math.factorial(20)
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
The slowest run took 5.91 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 484 ns per loop

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}20}]:} \PY{k}{def} \PY{n+nf}{fact}\PY{p}{(}\PY{n}{n}\PY{p}{)}\PY{p}{:}
             \PY{n}{num} \PY{o}{=} \PY{l+m+mi}{1}
             \PY{k}{while} \PY{n}{n} \PY{o}{\PYZgt{}}\PY{o}{=} \PY{l+m+mi}{1}\PY{p}{:}
                 \PY{n}{num} \PY{o}{=} \PY{n}{num} \PY{o}{*} \PY{n}{n}
                 \PY{n}{n} \PY{o}{=} \PY{n}{n} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1}
             \PY{k}{return} \PY{n}{num}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}21}]:} \PY{o}{\PYZpc{}}\PY{k}{timeit} fact(20)
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
The slowest run took 13.97 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 1.5 µs per loop

    \end{Verbatim}

    \subsection{Profiling}\label{profiling}

    Profiling complements what \textbf{timeit} does by splitting the overall
timing into the time spent in each function. It can give us a better
understanding of what our program is really spending its time on.

Suppose we want to create a list of even numbers. Our first effort
yields this:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}23}]:} \PY{k}{def} \PY{n+nf}{evens}\PY{p}{(}\PY{n}{n}\PY{p}{)}\PY{p}{:}
             \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Return a list of even numbers below n}\PY{l+s+s2}{\PYZdq{}}
             \PY{n}{l} \PY{o}{=} \PY{p}{[}\PY{p}{]}
             \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{n}\PY{p}{)}\PY{p}{:}
                 \PY{k}{if} \PY{n}{x} \PY{o}{\PYZpc{}} \PY{l+m+mi}{2} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
                     \PY{n}{l}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{x}\PY{p}{)}
             \PY{k}{return} \PY{n}{l}
\end{Verbatim}


    Is this code fast enough? We find out by running the Python profiler on
a longer run:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}24}]:} \PY{k+kn}{import} \PY{n+nn}{cProfile}
         \PY{n}{cProfile}\PY{o}{.}\PY{n}{run}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{evens(100000)}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
         50004 function calls in 0.028 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.021    0.021    0.028    0.028 <ipython-input-23-0230bb536e33>:1(evens)
        1    0.000    0.000    0.028    0.028 <string>:1(<module>)
    50000    0.004    0.000    0.004    0.000 \{method 'append' of 'list' objects\}
        1    0.000    0.000    0.000    0.000 \{method 'disable' of '\_lsprof.Profiler' objects\}
        1    0.002    0.002    0.002    0.002 \{range\}



    \end{Verbatim}

    This looks okay, 0.05 seconds isn't a \emph{huge} amount of time, but
looking at the profiling shows that the \textbf{append} function is
taking almost 20\% of the time. Can we do better? Let's try a list
comprehension.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}135}]:} \PY{k}{def} \PY{n+nf}{evens2}\PY{p}{(}\PY{n}{n}\PY{p}{)}\PY{p}{:}
              \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Return a list of even numbers below n}\PY{l+s+s2}{\PYZdq{}}
              \PY{k}{return} \PY{p}{[}\PY{n}{x} \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{n}\PY{p}{)} \PY{k}{if} \PY{n}{x} \PY{o}{\PYZpc{}} \PY{l+m+mi}{2} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{]}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}136}]:} \PY{k+kn}{import} \PY{n+nn}{cProfile}
          \PY{n}{cProfile}\PY{o}{.}\PY{n}{run}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{evens2(100000)}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
         4 function calls in 0.025 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.023    0.023    0.025    0.025 <ipython-input-135-7861f090b1c9>:1(evens2)
        1    0.000    0.000    0.025    0.025 <string>:1(<module>)
        1    0.000    0.000    0.000    0.000 \{method 'disable' of '\_lsprof.Profiler' objects\}
        1    0.002    0.002    0.002    0.002 \{range\}



    \end{Verbatim}

    By removing a small part of the code using a list comprehension, we've
doubled the overall speed of the code!

It seems like \textbf{range} is taking a long time, still. Can we get
rid of it? We can, using the \textbf{xrange} generator:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}203}]:} \PY{k}{def} \PY{n+nf}{evens3}\PY{p}{(}\PY{n}{n}\PY{p}{)}\PY{p}{:}
              \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Return a list of even numbers below n}\PY{l+s+s2}{\PYZdq{}}
              \PY{k}{return} \PY{p}{[}\PY{n}{x} \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{n+nb}{xrange}\PY{p}{(}\PY{n}{n}\PY{p}{)} \PY{k}{if} \PY{n}{x} \PY{o}{\PYZpc{}} \PY{l+m+mi}{2} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{]}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}204}]:} \PY{k+kn}{import} \PY{n+nn}{cProfile}
          \PY{n}{cProfile}\PY{o}{.}\PY{n}{run}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{evens3(100000)}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
         3 function calls in 0.021 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.021    0.021    0.021    0.021 <ipython-input-203-3ee1b2b2b034>:1(evens3)
        1    0.001    0.001    0.021    0.021 <string>:1(<module>)
        1    0.000    0.000    0.000    0.000 \{method 'disable' of '\_lsprof.Profiler' objects\}



    \end{Verbatim}

    This is where profiling can be useful. Our code now runs 3x faster by
making trivial changes. We wouldn't have thought to look in these places
had we not had access to easy profiling. Imagine what you would find in
more complicated programs.

    \section{VII. References}\label{vii.-references}

\subsection{Learning Resources}\label{learning-resources}

\begin{itemize}
\tightlist
\item
  \href{http://docs.python.org/2.7}{Official Python Documentation},
  including

  \begin{itemize}
  \tightlist
  \item
    \href{http://docs.python.org/2.7/tutorial}{Python Tutorial}
  \item
    \href{http://docs.python.org/2.7/reference}{Python Language
    Reference}
  \end{itemize}
\item
  If you're interested in Python 3, the
  \href{http://docs.python.org/3/}{Official Python 3 Docs are here}.
\item
  \href{http://ipython.org/ipython-doc/dev/interactive/tutorial.html}{IPython
  tutorial}.
\item
  \href{http://learnpythonthehardway.org/book/}{Learn Python The Hard
  Way}
\item
  \href{http://www.diveintopython.net/}{Dive Into Python}, in particular
  if you're interested in Python 3.
\item
  \href{http://inventwithpython.com/}{Invent With Python}, probably best
  for kids.
\item
  \href{http://docs.python.org/2/howto/functional.html}{Python
  Functional Programming HOWTO}
\item
  \href{http://mitpress.mit.edu/sicp/full-text/book/book.html}{The
  Structure and Interpretation of Computer Programs}, written in Scheme,
  a Lisp dialect, but one of the best books on computer programming ever
  written.
\item
  \href{http://www.dabeaz.com/generators/}{Generator Tricks for Systems
  Programmers} Beazley's slides on just what generators can do for you.
\item
  \href{http://pymotw.com/2/contents.html}{Python Module of the Week} is
  a series going through in-depth analysis of the Python standard
  library in a very easy to understand way.
\end{itemize}

\subsection{Badass IPython Notebooks}\label{badass-ipython-notebooks}

\begin{itemize}
\tightlist
\item
  Rob Johansson's \href{http://jrjohansson.github.io/}{excellent
  notebooks}, including
  \href{https://github.com/jrjohansson/scientific-python-lectures}{Scientific
  Computing with Python} and
  \href{https://github.com/jrjohansson/qutip-lectures}{Computational
  Quantum Physics with QuTiP} lectures;
\item
  \href{http://nbviewer.ipython.org/url/jakevdp.github.com/downloads/notebooks/XKCD_plots.ipynb}{XKCD
  style graphs in matplotlib};
\item
  \href{https://github.com/ipython/ipython/tree/master/examples/notebooks\#a-collection-of-notebooks-for-using-ipython-effectively}{A
  collection of Notebooks for using IPython effectively}
\item
  \href{https://github.com/ipython/ipython/wiki/A-gallery-of-interesting-IPython-Notebooks}{A
  gallery of interesting IPython Notebooks}
\item
  \href{https://github.com/invisibleroads/crosscompute-tutorials}{Cross-disciplinary
  computational analysis IPython Notebooks From Hadoop World 2012}
\item
  \href{http://nbviewer.ipython.org/urls/raw.github.com/tbekolay/pyconca2012/master/QuantitiesTutorial.ipynb}{Quantites}
  Units in Python.

  \begin{itemize}
  \tightlist
  \item
    \href{http://www.southampton.ac.uk/~fangohr/blog/}{Another units
    module is here}
  \end{itemize}
\end{itemize}

\subsection{Packages for Scientists}\label{packages-for-scientists}

Important libraries

\begin{itemize}
\tightlist
\item
  \href{http://www.python.org}{Python} version 2.7;
\item
  \href{http://www.numpy.org}{Numpy}, the core numerical extensions for
  linear algebra and multidimensional arrays;
\item
  \href{http://www.scipy.org}{Scipy}, additional libraries for
  scientific programming;
\item
  \href{http://matplotlib.sf.net}{Matplotlib}, excellent plotting and
  graphing libraries;
\item
  \href{http://ipython.org}{IPython}, with the additional libraries
  required for the notebook interface.
\item
  \href{http://sympy.org}{Sympy}, symbolic math in Python
\item
  \href{http://pandas.pydata.org/}{Pandas} library for big data in
  Python
\end{itemize}

Other packages of interest

\begin{itemize}
\tightlist
\item
  \href{http://pyquante.sf.net}{PyQuante} Python Quantum Chemistry
\item
  \href{https://code.google.com/p/qutip/}{QuTiP} Quantum Toolbox in
  Python
\item
  Konrad Hinsen's
  \href{http://dirac.cnrs-orleans.fr/plone/software/scientificpython/}{Scientific
  Python} and \href{http://dirac.cnrs-orleans.fr/MMTK/}{MMTK}
\item
  \href{https://wiki.fysik.dtu.dk/ase/}{Atomic Simulation Environment}
\end{itemize}

\subsection{Cool Stuff}\label{cool-stuff}

\begin{itemize}
\tightlist
\item
  \href{http://moinmo.in/}{Moin Moin}, a wiki written in Python
\item
  \href{http://projecteuler.net/}{Project Euler}, programming problems
  that would (?) have interested Euler. Python is one of the most
  commonly used languages there.
\end{itemize}

    \section{VI. Acknowledgements}\label{vi.-acknowledgements}

Thanks to Alex and Tess for everything!

Thanks to Barbara Muller and Tom Tarman for helpful suggestions.

    This work is licensed under a
\href{http://creativecommons.org/licenses/by-sa/3.0/deed.en_US}{Creative
Commons Attribution-ShareAlike 3.0 Unported License}. The work is
offered for free, with the hope that it will be useful. Please consider
making a donation to the \href{http://numfocus.org/johnhunter/}{John
Hunter Memorial Fund}.

\begin{figure}
\centering
\includegraphics{http://i.creativecommons.org/l/by-sa/3.0/88x31.png}
\caption{CC BY SA}
\end{figure}

\begin{figure}
\centering
\includegraphics{http://upload.wikimedia.org/wikipedia/commons/thumb/3/32/Sandia_National_Laboratories_logo.svg/200px-Sandia_National_Laboratories_logo.svg.png}
\caption{Sandia}
\end{figure}

Sandia is a multiprogram laboratory operated by Sandia Corporation, a
Lockheed Martin Company, for the United States Department of Energy's
National Nuclear Security Administration under Contract
DE-AC04-94AL85000.

\begin{figure}
\centering
\includegraphics{http://upload.wikimedia.org/wikipedia/commons/thumb/b/bf/US-DeptOfEnergy-Seal.svg/200px-US-DeptOfEnergy-Seal.svg.png}
\caption{DOE}
\end{figure}


    % Add a bibliography block to the postdoc
    
    
    
    \end{document}
